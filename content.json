{"meta":{"title":"Noir's Blog","subtitle":"","description":"Noir的博客","author":"Noir","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-06-17T18:58:20.973Z","updated":"2023-06-17T18:58:20.973Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"联系我 邮箱:&#x6e;&#111;&#x69;&#114;&#112;&#117;&#112;&#105;&#x6c;&#108;&#101;&#115;&#97;&#105;&#x73;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#x6d; 错误指正 关于本站仅作为个人存放日常学习资料和遇到的问题总结,由于本人水平有限,且部分老的博文是在尚不成熟时写的,故难免会存在过时内容或错误.如有发现,请直接在评论区指正."},{"title":"","date":"2023-06-18T10:44:14.617Z","updated":"2023-06-18T10:44:14.617Z","comments":true,"path":"custom/darkmode.css","permalink":"http://example.com/custom/darkmode.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label { color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer { background-color: #292a2d; } .DarkMode strong, .DarkMode img { filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky { background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before { opacity: 1 } .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"archives","date":"2023-06-17T13:45:05.000Z","updated":"2023-06-17T14:57:39.589Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-06-18T10:44:03.527Z","updated":"2023-06-18T10:44:03.527Z","comments":true,"path":"custom/darkmode.js","permalink":"http://example.com/custom/darkmode.js","excerpt":"","text":"function BackTOP() { $(\"#btn\").hide(); $(function () { $(window).scroll(function () { if ($(window).scrollTop() > 50) { $(\"#btn\").fadeIn(200); } else { $(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); $(function () { $(\"#say\").click(function () { $('body,html').animate({ scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () { $('body').toggleClass('read-mode') }) function SiderMenu() { $('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() { $('').appendTo($(\"body\")), setTimeout( function () { (volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () { $(\".Cuteen_DarkSky\").fadeOut(1e3, function () { $(this).remove() }) }, 2e3) }), 50 } function checkNightMode() { if ($(\"html\").hasClass(\"n-f\")) { $(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) { $(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") { $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else { $(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); window.addEventListener('load', ()=>{ volantis.dark.push(()=>{ switchNightMode(); }) }, {once: true})"},{"title":"所有分类","date":"2023-06-19T11:34:46.336Z","updated":"2023-06-19T11:34:46.336Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-06-17T19:02:28.248Z","updated":"2023-06-17T19:02:28.248Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"友链暂不开放哦!!","text":"友链暂不开放哦!!"},{"title":"所有标签","date":"2023-06-19T11:35:13.399Z","updated":"2023-06-19T11:35:13.399Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ADB-命令","slug":"ADB-命令","date":"2023-06-26T11:17:56.000Z","updated":"2023-06-26T12:02:56.997Z","comments":true,"path":"2023/06/26/ADB-命令/","link":"","permalink":"http://example.com/2023/06/26/ADB-%E5%91%BD%E4%BB%A4/","excerpt":"","text":"adb 基本语法1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 命令行参数 -d：指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e：指定当前唯一运行的模拟器为命令目标 **-s **：指定相应 serialNumber 号的设备&#x2F;模拟器为命令目标 为啥需要指定设备为命令目标？如果有多个设备&#x2F;模拟器连接，需要为命令指定目标设备，否则怎么知道要操作哪台设备 重点 如果只有连了一台设备，那就不需要 -d、-e、-s 参数了 在多个设备&#x2F;模拟器连接的情况下较常用的是 -s 参数，serialNumber 为设备到序列号，设备连接上电脑后可以通过 adb devices 命令获取 serialNumber 可能是序列号也可能是 IP 查看序列号 这里是 IP+端口 查看当前 adb 连接上的设备列表1adb devices 杀掉 adb 服务1adb kill-server 开启 adb 服务1adb start-server adb 安装 app1adb install 包地址 adb 卸载 app1adb uninstall 包名 把文件从手机中复制到电脑1adb pull &lt;手机路径&gt; &lt;电脑路径&gt; 把文件从电脑复制到手机上1adb push &lt;电脑路径&gt; &lt;手机路径&gt; 以 root 权限运行 adb1adb root 存在一些需要 root 权限才能执行的命令 取消 root 权限1adb unroot 指定 adb server 的网络端口12# 默认端口为 5037adb -P &lt;port&gt; start-server 指定设备 ID1adb -s 09091JEC212986 logcat -v time 查看手机型号1adb shell getprop ro.product.model 查看电池状况1adb shell dumpsys battery 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 50% 的电量。 查看分辨率1adb shell wm size 设备屏幕分辨率为 1920px * 1080px 查看屏幕密度1adb shell wm density 设备屏幕密度为 240dpi 查看显示屏参数1adb shell dumpsys window displays 查看android_id1adb shell settings get secure android_id 查看 Android 系统版本1adb shell getprop ro.build.version.release *查看IP地址，网卡相关*1adb shell ifconfig 查看Mac地址1adb shell cat /sys/class/net/网卡/address 我的网卡是 eth0 也可以用下面的命令查看 1adb shell netcfg *查看CPU信息*1adb shell cat /proc/cpuinfo ***查看内存信息*****1adb shell cat /proc/meminfo 查看硬件与系统属性查看所有属性1adb shell cat /system/build.prop 单独查看属性1adb shell getprop &lt;属性名&gt; 常用属性列表 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 应用管理查看应用列表语法格式1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 命令行参数列表 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 包名包含的字符串 例子查看系统应用1adb shell pm list packages -s 查看第三方应用1adb shell pm list packages -3 查看某个包名中包含指定字符的应用12345# 比如要查看包名包含字符串 java 的应用列表 adb shell pm list packages java # 也可以使用 grep 来过滤adb shell pm list packages | grep java 安装应用语法格式1adb install [-lrtsdg] &lt;path_to_apk&gt; 命令行参数列表 参数 含义 -l 将应用安装到保护目录 &#x2F;mnt&#x2F;asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定android:testOnly&#x3D;”true”的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 卸载应用1adb uninstall [-k] &lt;packagename&gt; 表示应用的包名 -k 参数可选，表示卸载应用但保留数据和缓存目录。 清除应用数据和缓存1adb shell pm clear &lt;packagename&gt; 这条命令的效果相当于在设置里的应用信息界面点击了清除缓存和清除数据 查看当前运行的 APP 的页面 Activity 信息两条命令差不多效果 1adb shell &quot;dumpsys window | grep mCurrentFocus&quot; 1adb shell &quot;dumpsys activity activities | grep mFocusedActivity&quot; 查看某个包的版本号1adb shell dumpsys package 包名 | findstr versionName 查看应用安装路径1adb shell pm path &lt;PACKAGE&gt; 杀死一个应用进程1adb shell kill [pid] 不过一般先要获得 PID12345678# 查看所有进程信息的命令adb shell ps# 可以通过 grep 筛选进程名称来查 PIDadb shell &quot;ps |grep water&quot;# 结束进程adb shell kill pid 日志Android 系统的日志分为两部分 底层的 Linux 内核日志输出到 &#x2F;proc&#x2F;kmsg Android 的日志输出到 &#x2F;dev&#x2F;log 语法格式1adb logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 按优先级过滤日志 Android 的日志分为如下几个优先级 V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 小例子1adb logcat *:W 该命令会将 Warning、Error、Fatal 和 Silent 日志输出。 记得固定写法哦 *:W 指定日志格式1adb logcat -v &lt;format&gt; brief12345&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;# 示例D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process123456── (&lt;tag&gt;)&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; # 示例 ── (MAXHUB-PostBonjourInfoRunnable)D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag12345&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; # 示例D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw12345&lt;message&gt;# 示例Disconnected process message: 10, size: 0 time12345&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;# 示例08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime12345&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; # 示例08-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long1234567[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt;# 示例[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 清空日志1adb logcat -c 查看内核日志1adb shell dmesg 其他屏幕截图1adb exec-out screencap -p &gt; sc.pn 截图保存到电脑执行该命令的目录下 如果指定文件名以 .png 结尾时可以省略 -p 参数 注意如果 adb 版本较老，无法使用 exec-out 命令，建议更新 adb 版本 也可以用下面的步骤来完成 12345# 先截图保存到设备里adb shell screencap -p /sdcard/sc.png # 然后将 png 文件导出到电脑adb pull /sdcard/sc.png 录制屏幕12345# 录制屏幕以 mp4 格式保存到 /sdcardadb shell screenrecord /sdcard/filename.mp4 # 导出到电脑adb pull /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒 查看wifi密码1adb shell cat /data/misc/wifi/*.conf 删除系统默认APP找到要删除的包名1adb shell pm list packages -s 获取包名的地址1adb shell pm path 包名 【如：adb shell pm path com.seewo.rainbow.pro】 获取root权限1adb root adb remount 挂载系统读写权限1adb shell rm 包名地址 删除包1adb shell rm -r /data/app/com.seewo.rainbow.pro-1 重启1adb reboot","categories":[{"name":"ADB","slug":"ADB","permalink":"http://example.com/categories/ADB/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://example.com/tags/ADB/"},{"name":"APP","slug":"APP","permalink":"http://example.com/tags/APP/"}]},{"title":"Fiddler-基本使用","slug":"Fiddler-基本使用","date":"2023-06-26T08:48:04.000Z","updated":"2023-06-26T08:55:30.815Z","comments":true,"path":"2023/06/26/Fiddler-基本使用/","link":"","permalink":"http://example.com/2023/06/26/Fiddler-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Fiddler的功能面板 1、statistics：请求的性能指标；全世界范围的性能测试； RTP：一个请求的从发送出去到返回的时间； Show chart可以看出图表的示例； 2、inspectors:对请求解包： header：请求头信息。UA,cookie,发送请求来源。 textView:可以看到返回的数据； imageview:可以看到返回的图片（如果有图片返回的话） webforms:看到请求传递的信息； cookies：请求携带的cookie； response header：响应报文的头文件 3、autoresponder: 文件代理：可以使用fiddler来自定义请求返回的文件。 当我们线上的出现bug的时候，可以使用线上返回 的文件在本地做一个修改，看看bug是否解除。 4、composer：前后端接口联调：可以将条目拖到composer然后进行模拟执行；伪造请求。不写js实现跟服务器交互。类似postman。 5、log : 使用fiddler的日志； 6、filters：过滤功能，可以很好帮助只显示我们关心的请求或者隐藏掉我们不关心的请求。 7、timeline: 网站性能分析，一个网站的请求多个网站请求进行，选中查看timeline查看请求详情。 一、Statistics数据统计面板，性能分析 重点****：主要关注RTT，体现一个请求从发送到返回响应的时间 反映一个请求的性能指标，其中主要需要关注RTT 会展示全世界范围的请求平均数据 show chart按钮，从饼状图中分别出哪些资源的请求耗时最多，从而对页面的访问进行访问速度优化 二、Inspectors查看请求与响应 Headers****：查看Header WebForms：用表格的形式查看body的值和请求参数的值 TextView&#x2F;WebView：无格式化查看数据 Cookies****：查看header中cookie的值 Raw：查看完整的消息结构 JSON：以JSON格式查看数据（类似Charles默认显示响应数据的格式） 三、Filters过滤器1、User Filters启用 2、ActionAction： Run Filterset now运行过滤器 Load Filterset导入过滤规则 Save Filterset保存过滤器到本地 如下截图： 过滤监控会话，筛选和标记会话，或进行一些轻量级的修改；fiddler默认会检查http头中设置的host，标记或隐藏部分会话，选择隐藏的时候，fiddler仍然会代理通信的主机，只是将对应会话隐藏在监控面板 （文本框内输入需要标记或过滤的域名，多个域名使用”;”分号分割） 3、过滤器实际应用3.1 过滤器实际应用一：只根据域名进行过滤 3.2 过滤器实际应用二：根据域名进行过滤，并过滤掉图片类型的请求 四、AutoResponder请求重定向目的：允许从本地返回文件，代替服务器响应，而不用将文件发布到服务器【可用正式环境验证本地文件】。 关于Fiddler的AutoResponder重定向功能，主要是时进行会话的拦截，然后替换原始资源的功能。 1、什么是请求重定向？所谓请求无非就是需要调用到的一些资源(包括JS、CSS和图片等)，所谓重定向就是将页面原本需要调用的资源指向其他资源(你能够控制的资源或者可以引用到的资源)。 2、为什么要用这个功能？ AutoResponder类似于Charles的MapLocal功能，但是更强大，因为可以用正则去匹配； 平时我们可能需要观察某个请求返回特定的响应数据，但是该请求可能每次都会带有唯一的请求参数（如：时间戳），那就可以通过AutoResponder的正则去匹配该请求，无需url里关心唯一的请求参数，而且也可以根据Header的属性去匹配url； 甚至Fiddler还提供了多种response，不一定要自定义一个response。 接下来，就是页面介绍： 红色圈：执行匹配规则，就是用来启动AutoResponder 绿色圈：不匹配请求失败的url 蓝色圈：添加匹配规则 橘色圈：因为正则较为复杂，可以用Test去测试自己写的正则能否匹配上对应url 3、使用方法 需要勾选enable rules、unmatched requests passthrough选项 将左侧监控面板中截获到的请求，拖到Autoresponder面板中，选中该请求-右键-Edit response-textview，可修改服务端返回的内容（建议格式化之后再做修改，返回的内容结构会更清晰），点击【save】按钮，并勾选该请求前方的复选框——客户端重新发起该请求的时候，就会返回修改的内容。 http://www.bejson.com/ json校验格式化工具 下方规则编辑框：默认精准匹配，完全相同的请求地址才会被拦截，该编辑框支持正则表达式进行模糊匹配，如regex:(?insx).*.(css|js|PHP)$ 表示匹配所有以css,js,php结尾的请求url 下方规则下拉框：可选择服务器返回不同的code值或返回一个本地文件；Fiddler支持的拦截重定向的方式： 4、AutoResponder具体匹配规则写法（重中之重）注意：如果Test URL输入框中显示绿色代表匹配成功，显示红色则匹配失败 4.1 字符串匹配（相当于模糊匹配）匹配规则：path1&#x2F; http://www.example.com/**Path1/**query=example http://www.example.com/returnUrl=**Path1/**OtherPlace 4.2 NOT匹配匹配规则：NOT:path1&#x2F; http://www.example.com/Path2/query=example 4.3 EXACT精确匹配（完全匹配）匹配规则：EXACT:http://www.example.com/path http://www.example.com/path http://www.example.com/Path http://www.example.com/path/query=“” 4.4 regex正则表达式匹配.+ 一个或多个 .* 零个或多个 （？insx）不区分大小写 \\ 转义 匹配规则：regex:(?inx)^https:&#x2F;&#x2F;.+.gif$ 简单理解：https开头，.gif结尾的url 5、AutoResponder实际运用5.1 场景设计：返回404给客户端（Fiddler有自带的404响应可选择）返回不同状态码可用于校验客户端是否正确处理错误码的展示效果 5.2 场景设计：返回200给客户端（Fiddler有自带的200响应可选择） 5.3 场景设计：返回自定义response 5.4 场景设计：返回原始响应文件修改之后的本地响应（类似Charles的MapLocal）首先，选中对应的请求》saveresponse》response body》本地修改响应 五、Composer构造器Fiddler Composer的功能就是用来创建HTTP Request 然后发送。你可以自定义一个Request, 也可以手写一个Request，你甚至可以在Web会话列表中拖拽一个已有的Request，来创建一个新的HTTP Request。 简单来说，Composer可以用来接口测试，支持前后端接口连调，支持多种类型的请求，如GET、POST。其中，POST请求的参数写在request body中、一般协议选择HTTP1.1。 Composer使用操作如下： 将左侧监控面板中截获到的请求，拖到composer面板中 修改parsed框Request Body（post请求需要修改，get请求不需要修改）中的值 点击右上角【Execute】按钮，即可按照修改后的请求头和参数值重新发起一次请求，重新发起的请求在左侧监控面板中可查看，修改后的请求内容在右侧history中有记录 1、Fiddler Composer的优势 能从”Web会话列表”中，拖拽一个先前捕获到的Request，可以进行篡改数据； 发送Request后，可以设置断点，继续修改Request； 支持在Request中上传文件； 支持重复发送多次Request。 2、Composer的实操 六、timeline网站性能分析选中多个请求，进行网站性能分析 Y轴：发送的请求列表 进度条为多线条型，则为缓冲模式；进度条为平滑的柱状，则为流模式 绿色圆圈：连接被重用；红色圆圈：新创建的连接 顶部圆圈：客户端连接到fiddler，下部圆圈：fiddler连接到目标服务器 灰色箭头图标&#x2F;红色！图标&#x2F;绿色闪电图标：服务器返回一个错误代码（3XX，4XX，5XX） 结尾处的红色X:意味着服务器发送了一个连接，连接被关闭或为private类型","categories":[{"name":"Fiddler","slug":"Fiddler","permalink":"http://example.com/categories/Fiddler/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"http://example.com/tags/Fiddler/"}]},{"title":"Fiddler-设置与安装证书","slug":"Fiddler-设置与安装证书","date":"2023-06-26T08:46:08.000Z","updated":"2023-06-26T08:49:12.672Z","comments":true,"path":"2023/06/26/Fiddler-设置与安装证书/","link":"","permalink":"http://example.com/2023/06/26/Fiddler-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6/","excerpt":"","text":"一、Fiddler常见设置Options位置：Tools-&gt;Options 二、移动端连上Fiddler作为代理注意：因为Charles也是默认8888端口，小心同时打开两个应用导致端口冲突。 1. IOS端连接Fiddler1.1 iOS 手机设置代理步骤：a.点击wifi蓝色感叹号 -&gt;点击底部配置代理 -&gt;点击手动 -&gt;输入服务器（IP）和端口（8888） 1.2 iOS 安装步骤：a.浏览器输入网址，提示是否允许显示描述文件，允许 -&gt;安装描述文件 b.打开设置 -&gt;通用 –&gt;关于本机 -&gt;证书信任设置 2. Android端连接Fiddler2.1 Android 手机设置代理步骤：a.长按wifi修改网络 -&gt;高级选项，代理，手动 –&gt;输入服务器主机名（IP）和服务器端口（8888） 然后，手机浏览器访问IP：端口号安装证书 2.2 Android 安装步骤：a.浏览器输入网址 -&gt;命名证书，确认即可 Fiddler界面介绍使用一、基本界面 1、：备注，添加之后在会话栏的Comment列中显示备注内容 2、Replay：再次发送对应请求【常用】 3、清除会话面板 4、Go：断点调试，点击go，执行下一步【常用】 5、Stream：代理模式。默认：缓冲模式。点击进行切换。 a.流模式streaming：将客户端的请求数据实时的传给服务端，更接近于浏览器本身的真实行为。 b.缓冲模式buffering：将客户端的请求数据缓冲起来，等数据写完之后再传给服务端。 6、Decode：解压请求。解压http请求里面的东西，帮助查看响应内容【常用】 7、 Keep：保持会话的数目 清除列表 清除所有对话 清除加载图片的请求 清除使用http connect方法的请求 清除状态码非200的请求 清除非浏览器发出的请求 清除已响应请求且未标记的请求 清除响应body一样的请求，只保留一个 1、Any Process：捕获请求，只看需要的请求。将“靶心”投向需要的请求 2、Find：查找请求，可以高亮所查找的请求【常用】 3、Save：保存会话 4、：截图，默认5秒后截图（电脑全屏） 5、：计时器 6、Browse：点击会话，再点击Browse，启动浏览器发送此请求，快速启动浏览器 7、Clear Cache：清空浏览器缓存 8、TextWizard：编码、解码文本内容，一般包含中文的请求都需要解码才能看到，所以复制url到TextWizard，然后选择URLDecode【常用】 9、TearOff：浮窗 10、msdn搜索：.net开发 二、会话图标 三、状态面板功能 1、控制台：可以输入一些命令行；输入help:可以看到常见的命令行； 2、capturing：fideler左下角，显示capturing表示正常工作；1、控制台：可以输入一些命令行；输入help:可以看到常见的命令行； 3、All Processes：过滤会话来源，web brower对会话进行过滤； 4、M&#x2F;N 记录当前展示会话的数量； 5、状态信息：状态条显示。 四、命令行工具 基础命令&lt;4k 筛选响应大小小于4kb大小的会话 &lt;4000 筛选响应大小小于4000字节大小的会话 &gt;4k 筛选响应大小大于4kb大小的会话 &gt;4000 筛选响应大小大于4000字节大小的会话 ?searchtext 筛选包含searchtext 内容的请求 &#x3D;status 筛选响应状态&#x3D;状态的会话 &#x3D;method 筛选请求方法&#x3D;方法的会话 @host 筛选包含host的会话 g、go 恢复所有断点会话 cls、clear 清除会话列表 start 开始监听会话 stop 停止监听会话 quit 退出fiddler 命令行设置断点命令bpu str 给包含str的url设置一个请求断点，只拦截请求，不拦截响应 bpu 清除请求断点 bpafter str 给包含str的url设置一个响应断点，只拦截响应，不拦截请求 bpafter 清除响应断点 bps 404 给状态码是404的请求设置一个断点 bps 清除状态码断点 bpm post 给请求方法为post的请求设置一个断点 bpm 清除请求方法断点 bold str 给包含str的url加粗 bold 清除加粗","categories":[{"name":"Fiddler","slug":"Fiddler","permalink":"http://example.com/categories/Fiddler/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"http://example.com/tags/Fiddler/"}]},{"title":"appium-基础操作","slug":"appium-基础操作","date":"2023-06-26T08:39:36.877Z","updated":"2023-06-26T08:42:22.393Z","comments":true,"path":"2023/06/26/appium-基础操作/","link":"","permalink":"http://example.com/2023/06/26/appium-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","excerpt":"","text":"基本代码(启动代码) 准备工作 123456781. 打开模拟器或者连接真机2. 打开 appium 并启动服务器3. 获取被测 app 的包名和界面名Windows:adb shell dumpsys window windows | findstr mFocusedAppadb shell dumpsys window | findstr mCurrentFocus com.android.settings/.Settings 代码 12345678910111213141516171819import timefrom appium import webdriverdesired_capabilities = &#123; &quot;platformName&quot;: &quot;Android&quot;, # 手机的平台 不区分大小写 &quot;platformVersion&quot;: &quot;7&quot;, # 版本, 写大版本即可,比如 6.2.1 可以写在 6.2 6 &quot;deviceName&quot;: &quot;emulator-5554&quot;, # 手机的名字,随便写一个字符串,不能不写 &quot;appPackage&quot;: &quot;com.android.settings&quot;, # 打开应用的包名 &quot;appActivity&quot;: &quot;.Settings&quot; # 界面名（也叫启动名）&#125;# 获取驱动 http://127.0.0.1:4723/wd/hub 连接appium服务，# python和appium通信使用http协议driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_capabilities)time.sleep(5)# 退出驱动driver.quit()# 注意：如果版本号写错，会有提示版本 noReset参数12345678910111213打开app，如果重置了，下次再次打开此app，会和新安装的app一样（没有缓存，重新输入密码，提示获取权限，引导页）desired_capabilities = &#123; &quot;platformName&quot;: &quot;Android&quot;, # 平台 不区分大小写 &quot;platformVersion&quot;: &quot;7&quot;, # 版本, 写大版本即可,比如 6.0 可以写在 6 &quot;deviceName&quot;: &quot;emulator-5554&quot;, # 手机的名字,随便写一个字符串,不能不写 &quot;appPackage&quot;: &quot;com.tpshop.malls&quot;, # 打开应用的包名 &quot;appActivity&quot;: &quot;.SPMainActivity&quot;, # 界面名 &quot;noReset&quot;: True&#125;&quot;noReset&quot;: True打开app，不重置；如果不传递此参数，打开app默认会重置应用。 app 的基本操作应用跳转123456# appium是支持跨应用的，同一个session可以打开多个 app# 使用场景：当需要打开其它app时，可以使用此方法driver.start_activity(appPackage, appActivity)- appPackage 包名- appActivity 界面名 获取包名和界面名12# 获取包名 driver.current_package# 获取界面名 driver.current_activity 使用场景：获取界面名，用于断言 关闭驱动和app12# driver.close_app()，关闭的是desired_capabilities中的app# 关闭驱动 driver.quit() 关闭了session会话 扩展：关闭指定app 1234扩展：# 指定app关闭，使用 driver.terminate_app(app的id)# app的id 就是 包名# close_app() 只能关闭desired_capabilities指定的app， 在将来会被舍弃 安装卸载判断是否安装12345678# 安装app，app_path 为安装文件完整路径名(写绝对路径) driver.install_app(app_path)# 卸载app，app_id为app包名 driver.remove_app(app_id)# 判断app是否安装，app_id为app包名 driver.is_app_installed(app_id) 路径解决办法 12345windows 的路径问题解决：1. 在路径前边的字符串前加上 r&quot;&quot; , 不会进行转义 r&quot;D:\\apks\\TPShop.apk&quot;2. 将 Windows 路径为： \\ 改为 linux路径： / &quot;D:/apks/TPShop.apk&quot;3. 将 \\ 改为 \\\\ &quot;D:\\\\apks\\\\TPShop.apk&quot; 将应用 置于后台12345# 将当前应用置于后台多少秒, 时间到了之后,会自动切换到前台# 使用场景：手机银行类app，应用置于后台一段时间，再切换到前台，需要重新进行身份认证# 语法：driver.background_app(seconds) &#x3D;&#x3D;2.2元素定位&#x3D;&#x3D;定位单个元素12345元素定位工具: 使用 SDK 中的 ui 工具# xpath语法回顾//*[@属性名=&#x27;属性值&#x27;]//*[contains(@属性名, &#x27;属性值&#x27;)] 定位单个元素12345元素定位工具: 使用 SDK 中的 ui 工具# xpath语法回顾//*[@属性名=&#x27;属性值&#x27;]//*[contains(@属性名, &#x27;属性值&#x27;)] 元素定位-定位一组元素1234# 通过另外一种写法来定位driver.find_elements() # 得到的是 列表, 如果没有找到,返回的也是空列表#注意： appium 只能定位到页面展示的元素 &#x3D;&#x3D;元素操作&#x3D;&#x3D;2.3.1点击&#x2F;输入&#x2F;清空1234567891011121314151617点击、el.click()输入、el.send_keys(内容)清空el.clear()补充：1.默认不能输入中文(Windows),想要输入中文, 需要在启动参数中添加如下内容 unicodeKeyboard 和 resetKeyboard 两个键值对, 值都是 Truedesired_capabilities&#123; &quot;unicodeKeyboard&quot;: True, &quot;resetKeyboard&quot;: True&#125;2. appium-python-client send_keys() 会将输入框中的内容进行清空后，再输入 获取元素文本、位置、大小**1234561. 获取文本el.text 2. 位置el.location3. 大小el.size 获取元素属性123456789101112134. 属性el.get_attribute(属性名 )- ID: resourceId- content-desc: content-desc- 获取 class: className- 获取 text ： text/name注意： 老版本appium 获取name属性，当content-desc为空时，获取的是text属性，当content-desc不为空时，返回是 content-desc 当前版本1.20 如何想获取content-desc直接传入 content-desc 滑动和拖拽&#x3D;&#x3D;swipe滑动&#x3D;&#x3D;123456789driver.swipe(start_x, start_y, end_x, end_y, duration=0)start_x: 起点X轴坐标 start_y: 起点Y轴坐标 end_x: 终点X轴坐标 end_y: 终点Y轴坐标duration: 滑动这个操作一共持续的时间长度，单位:ms, 时间越短，惯性越大，如果不需要惯性，设置5000左右。如果需要惯性-设置200ms练习：打开手机《设置》应用，完成下面的步骤:①.模拟手指从（500, 1600），滑动到（500, 500）的位置。 scroll 滑动1234567891011从一个元素滑动到另一个元素，直到页面自动停止driver.scroll(origin_el, destination_el, duration) origin_el: 开始元素destination_el: 结束元素duration: 滑动时间滑动时间：时间越短，惯性越大案例：从 显示 滑动到 WLAN drag_and_drop123456从一个元素拖拽到另一个元素, 无惯性(精确滑动)driver.drag_and_drop(开始元素, 结束元素)注意：没有惯性，精准的滑动案例：从 显示 滑动到 WLAN 滑动方式选择12* 是通过坐标滑动还是通过元素滑动* 是否需要惯性 通过坐标滑动 不需要惯性 swipe，持续时间duration设置的长一些（4000-5000ms） 需要惯性 swipe，持续时间duration设置短一些(100-200ms) 通过元素滑动 不需要惯性 scroll + duration设置长一些（4000-5000ms） drag_and_drop 需要惯性 scroll+duration设置的短一些(100-200ms) web-editor 有一些面试会提到，市面上有些人会使用这个工具 1234# 安装pip install weditor==0.6.3# 启动weditor 注意：运行代码前，需要关闭weditor 如果未手动停止，则报如下错误 appium自带查询元素信息1.启动appium服务器 2.创建New Session Window 5.真机调试华为 安装手机助手 手机连入计算机，会提示安装 使用360软件-搜索手机助手 根据手机助手进行连接 开启开发者模式 开启adb 和 usb调试模式 安装手机助手进行调试(和手机品牌有关) 查看是否连接成功 &#x3D;&#x3D;手势操作&#x3D;&#x3D;基本语法1234567891011移动端的手势操作 类似 web 端的鼠标操作1. 创建TouchAction对象 touch_action = TouchAction(driver)2. 调用高级手势对象提供所想执行的手势方法 touch_action.手势方法3. 执行手势 touch_action.perform()-----另外一种写法TouchAction(driver).手势方法.perform() 轻敲 tap123456789轻敲的结果类似 点击tap(el, x, y)- el: 元素对象- x: 点击 x 坐标- y: 点击 y 坐标注意：1.元素对象 和 坐标 任选其一,不用两个都选2.如果通过 坐标进行点击，页面打开需要时间，带点击前需要手动等待 time.sleep() 按下 和 抬起123456789101. 按下press(el=None,x=None,y=None)2. 抬起release()模拟 轻敲 (按下马上抬起)press(el=None,x=None,y=None).release()模拟 长按(按下不抬起)press(el=None,x=None,y=None) 长按1234long_press(el, x, y, duration=1000)- el: 元素对象- x, y: 坐标- duration: 长按的时间,单位时间是毫秒 思考时间12wait(ms) # ms 毫秒, 暂停多长时间使用按下和抬起 组合思考时间，实现长按 1234# 通过 press release wait 模拟长按3秒driver.find_element_by_xpath(&quot;//*[@text=&#x27;WLAN&#x27;]&quot;).click()time.sleep(2)TouchAction(driver).press(x=280, y=490).wait(3000).release().perform() 移动 move_to12345ove_to(el, x, y)# 实际场景1. 想移动,需要先按下2. 移动完成后, 需要抬起 一个app 一般 只有一个启动页，一般是首页 滑动操作实际是使用了手势操作-TouchAction 123456# swipe 代码def swipe(self: T, start_x: int, start_y: int, end_x: int, end_y: int, duration: int = 0) -&gt; T: action = TouchAction(self) action.press(x=start_x, y=start_y).wait(ms=duration).move_to(x=end_x, y=end_y).release() action.perform() return self &#x3D;&#x3D;手机操作&#x3D;&#x3D;获取屏幕分辨率和截图12345语法：获取手机分辨率: driver.get_window_size() ---&gt; 字典 &#123;&#x27;width&#x27;: 1440, &#x27;height&#x27;: 2392&#125;截图: get_screenshot_as_file(filename) time.strftime(&#x27;%Y%m%d-%H%M%S&#x27;) 给文件名添加后缀 获取和设置网络状态123456781. 获取网络状态driver.network_connection 2. 设置网络状态driver.set_network_connection(connection_type)- connection_type: 网络类型(0, 1, 2, 4, 6)@property 装饰器，可以将 实例方法作为属性来使用 获取和设置网络状态123456781. 获取网络状态driver.network_connection 2. 设置网络状态driver.set_network_connection(connection_type)- connection_type: 网络类型(0, 1, 2, 4, 6)@property 装饰器，可以将 实例方法作为属性来使用 发送键到设备(按键操作)1234567891011121314151617语法：driver.press_keycode(keycode)常用：Home 键(返回主页) 3返回键 4音量增加键 24音量减少键 25回车键 66注意：# 1.音量大小未显示时，按 音量加和音量减 只会唤醒 音量大小调整界面# 2.按键过快，会产生无效按键操作keycode查询https://blog.csdn.net/feizhixuan46789/article/details/16801429 &#x3D;&#x3D;通知栏的操作&#x3D;&#x3D;123456语法：打开通知栏: driver.open_notifications()appium官方并没有为我们提供关闭通知的api，那么 现实生活中怎么关闭，就怎样操作就行，比如，1.手指从下往 上滑动2.按返回键 &#x3D;&#x3D;获取 toast 信息&#x3D;&#x3D;toast操作 介绍： 操作过程中弹出的立即消失的弹出框， 本质上它也是页面的一个元素。 如何获取toast：建议使用xpath查询，因为使用工具很难定位到元素。 1driver.find_element(By.XPATH, &quot;//*[contains(@text, &#x27;toast中的部分文本内容&#x27;)]&quot;) 使用显示等待查找元素： 隐式等待的下一次找元素的频率，不适合这种一闪而过的toast 1element = WebDriverWait(driver, 30, 0.1).until(lambda x: x.find_element(By.XPATH, &quot;//*[contains(@text,&#x27;再次点击&#x27;)]&quot;)) 补充说明 新版本的appium软件，支持Uiautomator2 因此不需要安装特殊环境 123低版本的 appium(&lt;=1.13) 需要在启动参数中添加如下内容:desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27;高版本默认使用的就是 封装方法-获取toast 获取toast封装获取toast文本内容 1234567891011121314# 提供要获取toast部分文本，判断toast是否存在，如果存在，则返回文本内容，如果没有找到，则抛出异常文本未找到from selenium.webdriver.common.by import Byfrom selenium.webdriver.support.wait import WebDriverWaitdef get_toast(driver, content): &quot;&quot;&quot;根据部分toast，获取完整toast信息&quot;&quot;&quot; el_xpath = f&quot;//*[contains(@text, &#x27;&#123;content&#125;&#x27;)]&quot; el = WebDriverWait(driver, 10, 0.5).\\ until(lambda x: x.find_element(By.XPATH, el_xpath)) return el.text webviewApp分类123Native App 原生app, Web App 使用浏览器打开的应用，页面是用HTML实现的Hybrid App 混合应用, 在原生 app 中嵌套了 HTML 网页 手机中HTML页面如何操作 12webview 的作用是嵌套 HTML 页面.嵌套的 HTML 页面,不能直接使用移动端的元素定位,要使用 web 端的元素定位,就需要 web 端的 driver(Chrome) &#x3D;&#x3D;环境准备&#x3D;&#x3D;1.查看应用浏览器的版本。 方式一：在应用-&gt;显示系统进程-&gt;找到Android system webview版本。 不同手机模拟器和真机略有不同，推荐方式二 方式二：使用命令，在dos命令行中输入命令，在手机中查看 1adb shell am start -a android.intent.action.VIEW -d https://liulanmi.com/labs/core.html 2.下载对应的版本的浏览器内核 下载地址： http://npm.taobao.org/mirrors/chromedriver/ 3.根据手机浏览器版本在上面页面中找到对应的版本 https://cdn.npmmirror.com/binaries/chromedriver/2.42/notes.txt 4.解压放到固定目录。12# 将下载好的手机浏览器版本对应的驱动 chromedriver放置到没有中文的目录，建议不要放在path中D:\\tools\\app_tools\\chrome\\chromedriver.exe 5.程序配置”Chromdriver Binary Path”目录 打开 Appium-Server Desktop 程序配置”Chromdriver Binary Path”目录为第三部中的全路径。 点击 “Start Server”开启Appium Server Desktop &#x3D;&#x3D;webview 元素定位&#x3D;&#x3D;思路 浏览器本身是native的应用。 使用之前的native元素定位、交互即可 网页部分的内容是HTML页面， 和native部分使用了不同的上下文。 做完native部分的交互(地址输入、回车访问)之后。 需要切换到HTML页面。代码如下： 12# 在 原生应用和 webview 之间进行切换driver.switch_to.context(&quot;&quot;) 切换完成后使用web页面自动化的方式定位元素、进行操作即可。 注意：如果模拟器上的浏览器为chrome， web页面的定位只能使用CSS、XPATH定位， 其他不支持。 &#x3D;&#x3D;方法API&#x3D;&#x3D;123456789101112131415161718192021# 语法:获取所有的上下文,得到是列表driver.contexts [&#x27;NATIVE_APP&#x27;, &#x27;WEBVIEW_com.android.browser&#x27;]# 获取当前的上下文对象driver.context # 切换到指定的上下文对象driver.switch_to.context(上下文对象) # 备注：操作原生页面，需要切换到原生上下文，如果操作webview 需要切换到webview的上下文# 注意：# 部分版本的浏览器驱动存在问题原因会导致如下报错selenium.common.exceptions.InvalidArgumentException: Message: invalid argument: invalid locator (Session info: chrome=86.0.4240.198)请在 desired_capabilities添加如下两个参数&quot;chromeOptions&quot;: &#123;&#x27;w3c&#x27;: False&#125;Chrome和ChromeDriver组合默认在w3c模式下运行,只有手动指定 ChromeDriver运行模式为非w3c模式，才能规避这个bug","categories":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://example.com/tags/appium/"}],"author":"Noir"},{"title":"MySQL-数据库操作","slug":"MySQL-数据库操作","date":"2023-06-26T08:34:51.000Z","updated":"2023-06-26T08:38:34.253Z","comments":true,"path":"2023/06/26/MySQL-数据库操作/","link":"","permalink":"http://example.com/2023/06/26/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"","text":"数据库操作 创建数据库 查询数据库 改数据库 删除数据库 选择数据库 创建数据库语法格式123CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;]; 知识点 MySQL 的字符集（CHARACTER）和校对规则（COLLATION）是两个不同的概念 字符集：是用来定义 MySQL 存储字符串的方式 校对规则：定义了比较字符串的方式 1234567891011121314# 简单创建一个数据库create database yytest;# 添加条件判断，创建一个数据库create database if not exists yytests;# 指定数据库数据集，创建一个数据库create database if not exists yytestss character set utf8;# 指定字符串校验规则，创建一个数据库create database if not exists yytestsss character set utf8 collate utf8_general_ci;# 查看数据库创建的语句是什么show create database yytestsss; 查询数据库语法格式1SHOW DATABASES [LIKE &#x27;数据库名&#x27;]; 知识点 [ like ‘ ‘ ] 是可选项，用于匹配指定的数据库名称 [ like ‘ ‘ ] 可以模糊匹配，也可以精确匹配 数据库名由单引号 ‘ ‘ 包围，在navicat中可以双引号 12345678# 查询所有数据库show DATABASES;# 模糊匹配show databases like &#x27;%yytest%&#x27;;# 精确匹配show databases like &#x27;yytests&#x27;; 修改数据库语法格式123ALTER DATABASE [数据库名] &#123; [ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |[ DEFAULT ] COLLATE &lt;校对规则名&gt;&#125; 知识点 不一定要写数据库名，但需要当前有在使用的数据库 只能支持修改字符集和字符校验规则，如果要修改数据库名可以直接通过工具重命名数据库，Mysql暂时不支持语句修改 修改数据库不常用，了解即可 123456# 修改默认数据库的字符集use yytest;alter database character set utf8; # 修改指定数据库字符集和校验规则alter database yytest character set utf8 collate utf8_general_ci; 删除数据库语法格式1DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt; 知识点 如果删除不存在的数据库，则会报 1008 - Can’t drop database ‘yytest’; database doesn’t exist 所以建议，删除数据库一定要加上 if exists 12345# 简单删除数据库语句drop database yytest;# 如果存在才删除drop database if exists yytests; 选择数据库12# 选择数据库use yytestss; 知识点 作用：用来完成一个数据库到另一个数据库的跳转【切换当前操作的数据库】 当用 CREATE DATABASE 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定使用当前数据库 总的sql集合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# ====创建数据库====# 简单创建一个数据库create database yytest;# 添加条件判断，创建一个数据库create database if not exists yytests;# 指定数据库数据集，创建一个数据库create database if not exists yytestss character set utf8;# 指定字符串默认校验规则，创建一个数据库create database if not exists yytestsss character set utf8 collate utf8_general_ci;# 查看数据库创建的语句是什么show create database yytestsss;# ====查询数据库====# 查询所有数据库show DATABASES;# 模糊匹配show databases like &#x27;%yytest%&#x27;;# 精确匹配show databases like &#x27;yytests&#x27;;# ====修改数据库====# 修改默认数据库的字符集use yytest;alter database character set utf8; # 修改指定数据库字符集和校验规则alter database yytest character set utf8 collate utf8_general_ci;# ====删除数据库====# 简单删除数据库语句drop database yytestsss;# 如果存在才删除drop database if exists yytestss;drop database if exists yytests;# 选择数据库use yytest; 数据表操作 创建数据表 查看表结构 查看数据表的创建语句 复制数据表 修改数据表 删除数据表 创建数据表语法格式1CREATE TABLE &lt;表名&gt; ( [表定义选项] )[表选项][分区选项]; 知识点 表名：两种写法，可以直接写数据表的名字 tbl_name ，也可以 db_name.tbl_name ，先指定数据库再指定数据表名；后者写法是为了：无论是否在当前数据库，也能通过这种方式在指定数据库下创建表 表定义选项：一般都是 列名、列定义、默认值、约束、索引组成 12345678910111213141516171819# 创建数据表CREATE TABLE yytest ( id INT ( 10 ) NOT NULL UNIQUE PRIMARY KEY, uname VARCHAR ( 20 ) NOT NULL, sex VARCHAR ( 4 ), birth YEAR, department VARCHAR ( 20 ), address VARCHAR ( 50 ), yypolo VARCHAR ( 20 ) );# 指定数据库，创建数据表CREATE TABLE yytest.polotest ( id INT ( 10 ) NOT NULL UNIQUE PRIMARY KEY AUTO_INCREMENT, stu_id INT ( 10 ) NOT NULL, c_name VARCHAR ( 20 ), istester VARCHAR ( 50 ), grade INT ( 10 ) ); 查看表结构1desc yytest.yytest; 执行结果 知识点 Null：表示该字段是否可以存储 NULL 值 Key：表示该字段是否已编制索引。PRI 表示主键，UNI 表示UNIQUE 索引，MUL 表示某个给定值允许出现多次 Default：表示该字段是否有默认值，如果有，值是多少 Extra：表示该字段的附加信息，如 AUTO_INCREMENT 等 查看数据表的创建语句1show create table yytest; 执行结果 知识点不仅可以查看创建表时的详细语句，而且可以查看存储引擎和字符编码 复制数据表1234567891011121314# 仅复制表结构create table yytest2 like yytest;# 复制表结构和数据create table yytest3 as select * from yytest;# 仅复制表的指定字段结构create table yytest4 as select id,uname,sex from yytest where 1&lt;&gt;1;# 复制表的指定字段结构和数据create table yytest5 as select id,uname,sex from yytest;# 查看表创建语句：没有包含主键和自增show create table yytest5; 知识点 仅复制全部字段的结构直接加 like 复制表不包含主键、索引、自增等 修改数据表语法格式1ALTER TABLE &lt;表名&gt; [修改操作]; 知识点常用的修改表的操作 修改表名 修改字段数据类型或字段名 增加和删除字段 修改字段的排列位置 add、drop、change、modify、rename 修改表名语法格式1ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;； 注意 [TO] 加不加都行，不影响结果 修改表名不影响表结构 实际12alter table yytest2 rename to yytest22;alter table yytest22 rename yytest22; 修改字段排列顺序语法格式1ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt; [FIRST|AFTER 已存在的字段名]; 实际12345# 放在首位alter table yytest22 modify sex int(2) first;# 放在birth字段后面alter table yytest22 modify sex int(2) after birth; 修改字段数据类型语法格式1ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;; 实际12# 修改字段数据类型alter table yytest22 modify sex int(2); 修改字段名字语法格式1ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段&gt; &lt;新字段&gt; &lt;数据类型&gt;; 实际12345# 修改字段名alter table yytest22 change sex sexs int(2);# 修改字段数据类型和字段名alter table yytest22 change sexs sex varchar(4); 知识点change不仅可以改字段名，也可以改字段数据类型 添加字段语法格式1ALTER TABLE &lt;表名&gt; ADD &lt;字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]; 实际12345678# 添加字段alter table yytest22 add phone varchar(11);# 添加字段到首位alter table yytest22 add phone varchar(11) not null default 2 first;# 添加字段到某个字段后面alter table yytest22 add phone varchar(11) after sex; 删除字段语法格式1ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;； 实际12# 删除字段alter table yytest22 drop phone; 删除数据表语法格式1DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...] 可以看到跟删除库差不多 实际 12# 删除表如果存在drop table if exists yytest,polotest","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":"Noir"},{"title":"MySQL-查询指令","slug":"MySQL-查询指令","date":"2023-06-26T08:24:26.000Z","updated":"2023-06-26T08:28:02.448Z","comments":true,"path":"2023/06/26/MySQL-查询指令/","link":"","permalink":"http://example.com/2023/06/26/MySQL-%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/","excerpt":"","text":"select的语法格式12345678910SELECT&#123;* | &lt;字段列名&gt;&#125;[FROM &lt;表 1&gt;, &lt;表 2&gt;…[WHERE &lt;表达式&gt;[GROUP BY &lt;group by definition&gt;[HAVING &lt;expression&gt; [&#123;&lt;operator&gt; &lt;expression&gt;&#125;…]][ORDER BY &lt;order by definition&gt;][LIMIT[&lt;offset&gt;,] &lt;row count&gt;]] 例: 1select * from 数据表名; 知识点 * 通配符，代表查询所有字段 使用 * 时，只能按照数据表中字段的顺序进行排列，不能自定义字段排序 建议：不知道所需查询的列名称时，才用 * ，否则获取不需要的列数据会降低查询和所使用应用程序的效率 查询表的指定字段1select id,username,sex,department from 数据表名; 知识点 可以指定表的所有字段，然后更改字段顺序， 这种查询所有字段的写法比较灵活 也可以只指定某几个字段，多个字段用 , 隔开 常见关键字的执行顺序 from on join where group by having select distinct order by limit distinct - 去重distinct特别注意当使用distinct的时候，只会返回指定的字段，其他字段都不会返回，所以查询语句就变成去重查询语句 常见使用场景： 查看去重字段有哪几种值【返回值】 查看去重字段有多少个值【返回数量】 distinct的语法格式1SELECT DISTINCT &lt;字段名&gt;,&lt;字段名&gt;, FROM &lt;表名&gt;; 知识点 distinct只能在select语句中使用 distinct必须在所有字段前面 如果有多个字段需要去重，则会对多个字段进行组合去重，即所有字段的数据重复才会被去重 单个字段去重1select distinct age from &lt;表名&gt;; 多个字段去重1select distinct sex,age from &lt;表名&gt;; 查看去重字段有多少种值1select count(distinct age) from &lt;表名&gt;; 可以给字段 or 数据表取别名 取别名的好处就是：如果数据表太长或者字段名太长，查询结果显示就不够优雅，而且取别名还能中文命名，何乐而不为 特别注意表名取的别名不能和其他表名相同，字段名取的别名不能和其他字段名相同 as - 取别名语法格式谨记：as是可以忽略不写的哦 12&lt;表名&gt; [AS] &lt;别名&gt; &lt;字段名&gt; [AS] &lt;别名&gt; limit - 限制查询结果条数三种用法 指定初始位置 不指定初始位置 结合offset使用 limit指定初始位置语法格式1LIMIT 初始位置，记录数 知识点 初始位置从0开始 初始位置和记录数都必须为正整数 从第3条记录开始，一共返回两条记录1select * from yyTest limit 2,2; limit不指定初始位置的语法格式1LIMIT 记录数 知识点 记录数 &gt; 表里总记录数的话，就返回所有记录 默认初始位置就是第1条记录 一共返回五条记录1select * from yyTest limit 5; imit + offset组合使用的语法格式1LIMIT 记录数 offset 初始位置 知识点 和 limit 初始位置, 记录数 用法一样，只是多了个offset，参数位置换了下而已 从第2条记录开始，一共返回五条记录1select * from yyTest limit 5 offset 1; order by - 对查询结果进行排序语法格式1ORDER BY &lt;字段名&gt; [,&lt;字段名&gt;...] [ASC | DESC] ASC：升序排序，默认值 DESC：降序排序 注意点 order by关键字后可以跟子查询（后面展开讲） 如果字段值是NULL，则当最小值处理 如果指定多个字段排序，则按照字段的顺序从左往右依次排序 单字段排序根据id倒序排序1select * from yyTest order by id desc; 多字段排序先根据sex倒序排序，然后根据height升序排序1select * from yyTest order by sex desc, height asc; 知识点 对多个字段排序时，只有第一个排序字段有相同的值，才会对第二个字段进行排序，以此类推 如果第一个排序字段的所有数据都是唯一的，将不会对第二个排序字段进行排序，以此类推 按字母（A-Z进行排序，大小写不敏感） where - 条件查询语法格式1WHERE 查询条件 五种查询条件 比较运算符、逻辑运算符 between and 关键字 is null 关键字 in、exist 关键字 like 关键字 有哪些比较运算法？ &#x3D;：等于 &lt;&#x3D;&gt;：安全等于 !&#x3D;、&lt;&gt;：不等于 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;：小于、大于、小于等于、大于等于 有哪些逻辑运算符？ and、&amp;&amp;：所有查询条件均满足才会被查询出来 or、||：满足任意一个查询条件就会被查询出来 xor：满足其中一个条件，并且不满足另一个条件时，才会被查询出来 单一条件的查询一般单一条件查询用的就是比较运算符 123456select * from yyTest where id = 1;select * from yyTest where id != 1;select * from yyTest where height &gt; 170;select * from yyTest where height &gt;= 175;select * from yyTest where age &lt; 20;select * from yyTest where age &lt;= 20; 多条件的查询多条件的查询都需要使用逻辑运算符，下面的例子比较简单不展开描述 1234select * from yyTest where sex = 1 and height &gt;175;select * from yyTest where sex = 1 &amp;&amp; height &gt;175;select * from yyTest where height &lt; 165 or height &gt;175;select * from yyTest where height &lt; 165 || height &gt;175; 查询 age 小于 21，并且 height 小于 165 的学生信息和 age 大于 21，并且 height 小于等于 165 的记录 满足age&lt; 21 但 不满足height &gt;&#x3D;165 不满足age&lt;121 但 满足height &gt;&#x3D;165 1select * from yyTest where age &lt; 21 xor height &gt;= 165; like - 模糊查询语法格式12LIKE &#x27;字符串&#x27;NOT LIKE &#x27;字符串&#x27; NOT：取反，不满足指定字符串时匹配 字符串：可以是精确的字符串，也可以是包含通配符的字符串 LIKE支持 % 和 _ 两个通配符 is null是一个关键字来的，用于判断字段的值是否为空值（NULL） 空值 ≠ 0，也 ≠ 空字符串”” % 通配符查询的 % 应该是最常用的通配符了，它代表任意长度的字符串，包括0 比如： a%b 表示以字母 a 开头，以字母 b 结尾的任意长度的字符串；该字符串可以代表 ab、acb、accb、accrb 等字符串 查询username字段包含test的记录 1select * from yyTest where username like &quot;%test%&quot;; 查询username字段开头不为test且department字段等于seewo的记录1select * from yyTest where username not like &quot;test%&quot; and department = &quot;seewo&quot;; 知识点匹配的字符串必须加单引号或双引号 like “%test%” _ 通配符查询的 _ 只能代表单个字符，字符的长度不能等于0，即字符长度必须等于1；相对于 % 来说， _ 肯定没这么常用 比如： a_b 可以代表 acb、adb、aub 等字符串 查询username字段test开头且后面只跟一个字符结尾的记录1select * from yyTest where username like &quot;test_&quot;; like 区分大小写 默认情况下，like匹配的字符串是不区分大小写的； like “test1” 和 like “TEST1” 匹配的结果是一样的 如果需要区分大小写，需要加入 binary 关键字 不会返回任何记录，test1和test2不会被匹配到1select * from yyTest where username like binary &quot;TEST_&quot;; 使用转义符的 如果查询的字符串包含%，可以使用 \\ 转义符 实际场景：搜索功能，搜索框只输入%看是否返回所有记录，如果是的话证明没有做转义可以提个优化项哦！ 转义符+通配符联合使用的1select * from yyTest where username like &quot;%\\%&quot; 使用通配符的注意点 注意大小写：不加binary关键字的话，大小写是不敏感的 注意头部、尾部多余的空格： “ test% “ 是不会匹配到“test1”的 注意NULL：通配符是不能匹配到字段为NULL的记录的 不要过度使用通配符：因为Mysql对通配符的处理速度会比其他操作花费更长的时间 在确定使用通配符后：除非绝对有必要，否则不要把它们用在字符串的开始处，把通配符置于搜索模式的开始处，搜索起来是最慢的。 is null - 空值查询语法格式两种写法： 字段值为空 字段值不为空 12IS NULLIS NOT NULL 空值查询的查询sex字段为空的记录1select * from yyTest where sex is null; 查询sex字段不为空的记录1select * from yyTest where sex is not null; 知识点 is null 是一个整体，不能用 &#x3D; null 替代 is not null 同理，不能用 !&#x3D; null 或 &lt;&gt; 替代 between and - 范围查询语法格式12BETWEEN 取值1 AND 取值2NOT BETWEEN 取值1 AND 取值2 取值1：范围的起始值 取指2：范围的终止值 NOT：取反，不在取值范围内的值将被返回 例一：查询年龄在19-21之间的记录1select * from yyTest where age between 19 and 21; 例二：查询年龄不在19-21之间的记录1select * from yyTest where age not between 19 and 21; group by - 分组查询 group by 关键字可以根据一个或多个字段对查询结果进行分组 group by 一般都会结合Mysql聚合函数来使用 如果需要指定条件来过滤分组后的结果集，需要结合 having 关键字；原因：where不能与聚合函数联合使用 并且 where 是在 group by 之前执行的 语法格式1GROUP BY &lt;字段名&gt;[,&lt;字段名&gt;,&lt;字段名&gt;] group by 单字段分组对sex单个字段进行分组查询 1select * from yyTest group by sex; 知识点分组之后，只会返回组内第一条数据； group by 多字段分组先按照age进行分组，然后再在每个组内按department分组 1select * from yyTest group by age,department; 知识点 多个字段分组查询时，先按照第一个字段分组，如果第一个字段有相同值，则把分组结果再按第二个字段进行分组，以此类推 如果第一个字段每个值都是唯一的，则不会按照第二个字段再进行分组了，具体原理可看下图 group by + group_concat()group_concat()可以将分组后每个组内的值都显示出来 1select department,group_concat(username) as &quot;部门员工名字&quot; from yyTest group by department; group by +聚合函数的有什么聚合函数？ count()：统计记录的条数 sum()：字段值的总和 max()：字段值的最大值 min()：字段值的最小值 avg()：字段值的平均值 具体的1234567891011121314# count统计条数select count(*) from yyTest group by department;# sum总和select sum(age) from yyTest group by department;# max最大值select max(age) from yyTest group by department;# min最小值select min(age) from yyTest group by department;# 平均值select avg(age) from yyTest group by department; group by + with rollupwith rollup用来在所有记录的最后加上一条记录，显示上面所有记录每个字段的总和（不懂的直接看图） 1select GROUP_CONCAT(username) from yyTest group by department with rollup; 1select sum(age) from yyTest group by department with rollup; 1select count(*) from yyTest group by department with rollup ; having - 条件查询 having关键字对group by分组后的数据进行过滤 having支持where的所有操作符和语法 where 和 having 的一些差异性 where having 不可以使用聚合函数 可以使用聚合函数 数据 group by 前过滤 数据 group by 后过滤 查询条件中不可以使用字段别名 查询条件中可以使用字段别名 用于过滤数据行 用于过滤分组后的结果集 根据数据表的字段直接过滤 根据已查询出的字段进行过滤 语法格式1HAVING &lt;查询条件&gt; having 单独使用的根据age分组，将分组后的结果过滤出departmen为seewo的分组记录 1select *,GROUP_CONCAT(username) from yyTest group by age having department = &quot;seewo having + where 先查询sex &#x3D; 1的所有记录 将查询的记录按照department分组 然后过滤出department&#x3D;seewo的分组 1select *,GROUP_CONCAT(username) from yyTest where sex = &quot;1&quot; group by department having department = &quot;seewo&quot; having + where + 聚合函数 sex &#x3D; 1的所有记录 将查询的记录按照department分组 然后过滤出max(date) &gt; “2020-05-08”的分组 1select *,GROUP_CONCAT(date) from yyTest where sex = &quot;1&quot; group by department having max(date) &gt; &quot;2020-05-08&quot; 多表查询 cross join：交叉连接 inner join：内连接 left join：左外连接 right join：右外连接 union、union all：全连接 多表查询的区别 查询类型 简述 图表 inner join 获取两个表中字段相互匹配关系的记录即两表记录都不为null才会返回 left join 获取左表所有记录右表为空的字段补null right join 获取右表所有记录左表为空的字段补null union 获取左右表所有记录 cross join 两张表的笛卡尔积 利用条件表达式来消除交叉连接（cross join）的多余数据行 inner join通过 on 来设置条件表达式，如果没有加on的话，inner join和cross join是相同的 cross join … on 和 inner join … on 其实效果也是一样的（但在标准sql中，cross join是不支持on的，只是Mysql支持） inner join - 内连接语法格式1SELECT &lt;字段名&gt; FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; [ON子句] inner join 可以连接 ≥ 两个的表 inner join 也可以使用 where 来指定连接条件，但是 inner join … on 是官方标准写法，而且 where 可能会影响查询性能 inner join 也可以只写 join 不加 inner 标准内连接：查询每个员工的部门详细信息两张表相连 12select * from emp as a inner join dept as b on a.dept_id = b.id;select * from emp as a join dept as b on a.dept_id = b.id; 注意点可以看到emp表id&#x3D;7、9的数据是没有返回的，dept表id&#x3D;4的数据也是没有返回的，这就是inner join的特性：只有两张表相互匹配到的数据才会返回（满足查询条件的数据），简单理解就是：取交集 特殊内连接，自连接：查询有leader的员工以及leader信息自连接：同一张表相连 1select * from emp as a inner join emp as b on a.leader = b.id; 特殊内连接，不等值连接不等值连接：查询条件的逻辑运算符是大于或小于 1select * from emp as a inner join dept as b on a.dept_id &gt; b.id; 知识点 在多表查询的时候，字段名都需要通过表名指定 表名.字段名 如果表名太长可以用给表起别名，这样就变成 别名.字段名 ，如上面的 a 、 b 就是别名， a.dept_id 、 b.id 外连接分为两种：left join、right join 外连接显示的内容要比内连接多，是对内连接的补充 left join的主表是左表，从表是右表 right join的主表是右表，从表是左表 外连接会返回主表的所有数据，无论在从表是否有与之匹配的数据，若从表没有匹配的数据则默认为空值（NULL） 外连接只返回从表匹配上的数据 重点：在使用外连接时，要分清查询的结果，是需要显示左表的全部记录，还是右表的全部记录 left join、right join - 左连接、右连接语法格式12SELECT &lt;字段名&gt; FROM &lt;表1&gt; LEFT OUTER JOIN &lt;表2&gt; &lt;ON子句&gt;SELECT &lt;字段名&gt; FROM &lt;表1&gt; RIGHT OUTER JOIN &lt;表2&gt; &lt;ON子句&gt; 语法格式说明 outer可以省略，只写 left join 、 right join on是设置左连接的连接条件，不能省略 left join 例子SQL分析 主表：emp 从表：dept 根据 emp 表的员工 dept_id 和 dept 表的部门 id 进行匹配 因为 emp 是主表，所以最后两条记录的 dept_id 在 dept 表没有匹配到 id，但是仍然会查询出来，然后将右表的数据置为NULL 1select * from emp as a left join dept as b on a.dept_id = b.id; left join + where 例子SQL分析 主表：emp 从表：dept 若不看where，前面的查询结果和上面的例子一样 where的作用：将上面的查询结果集进行过滤，最终只返回 id 是 NULL的记录 1select * from emp as a left join dept as b on a.dept_id = b.id where b.id is null; 知识点 如果外连接中有 where 关键字，on是为了关联两张表，而where是将外连接查询的结果集进行条件筛选 所以执行顺序是：on -》 join -》 where on：筛选两张表可以进行连接数据 join：将筛选后的数据连接起来 where：将连接后的数据结果集再次条件筛选 right join 例子1select * from emp as a right join dept as b on a.dept_id = b.id; SQL分析 主表：dept 从表：emp 根据 dept 表的 id 和 emp 表的 dept_id 进行匹配 因为 dept 是主表，所以最后两条记录的 id 在 emp 表没有匹配到 dept_id，但是仍然会查询出来，然后将左表的数据置为NULL 其实Mysql并没有全连接，Oracle才有全连接（full join） 但是在MySQL中，union关键字可以达到同样的效果，所以这里也要介绍下union union - 全连接语法格式123456[sql1]UNION [ALL | DISTINCT][sql2]UNION [ALL | DISTINCT][sql3].... 语法格式说明 sql1、sql2、sql3：平时写的查询 sql，可以连接很多条 sql ALL：可选参数，返回所有结果集，包含重复数据 distinct：可选参数，删除结果集中重复的数据（默认只写 union 也会删除重复数据，所以不加也没事） union all 例子123select * from emp as a left join dept as b on a.dept_id = b.idunion allselect * from emp as a right join dept as b on a.dept_id = b.id; 蓝色圈子：第一条 sql 的查询结果 红色圈子：第二条 sql 的查询结果 union 例子123select * from emp as a left join dept as b on a.dept_id = b.idunionselect * from emp as a right join dept as b on a.dept_id = b.id; 上图是去重之后的结果，而没有去重的结果可以看union all 的例子或者下图 红色圈住的部分就是重复的数据，union 会进行去重，只保留一份数据 知识点（重点） 使用 union 连接的多条sql，每个 sql 查询出来的结果集的字段名称要一致【只需要名称一致即可，顺序可以不同，但建议相同】，可以看看下面的例子 最终 union 连接查询的结果集的字段顺序会以第一个 sql 查出来结果集的字段顺序为基准 union 连接的两条 sql ，各自指定的字段顺序不相同的例子123select name,id,leader,is_enable,dept_id from emp where dept_id = 1unionselect * from emp where leader = 0 从上图可以看出，第二条 sql 查出来的字段顺序和最终结果集字段顺序明显不一样，导致数据错乱的问题 所以！！union 连接的每条 sql 指定的字段顺序最好一致！！ **所以！！*union 连接的*每条 sql 指定的字段顺序最好一致！！ *所以！！**union 连接的**每条 sql 指定的字段顺序最好一致！！* 123select * from emp where dept_id = 1unionselect id,name,dept_id,leader,is_enable from emp where leader = 0 子查询在我们查询方法中是比较常用的，通过子查询可以实现多表查询 子查询是指：将一个查询语句嵌套在另一个查询语句中 子查询可以在select、update、delete语句中使用，还可以进行多层嵌套 子查询语法格式1WHERE &lt;表达式&gt; &lt;操作符&gt; (子查询) 语法格式说明 操作符可以是比较运算符、in、not in、exists、not exists not 当然就是取反啦 in 和 exists的一个比较 in exists 当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE； 用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE； 适合外表大而内表小的情况 适合内表大而外表小的情况 无论哪个表大，用 not exists 都比 not in 速度快 1、A是表达式，B是子查询结果集2、若A在B里面，则返回True 方便理解，画个图 比较运算符的查询部门是销售部的员工信息1select * from emp where dept_id = (select id from dept where name = &quot;销售部&quot;) 查询部门不是销售部的员工信息1select * from emp where dept_id &lt;&gt; (select id from dept where name = &quot;销售部&quot;) in 的例子SQL分析 从 dept 表查询部门名字为销售部or财务部的部门 id 然后从 emp 表查询 depte_id 在上面 id 结果集的记录 1select * from emp where dept_id in (select id from dept where name = &quot;财务部&quot; or name =&quot;销售部&quot;) 可以看看子查询 sql 的查询结果1select id from dept where name = &quot;财务部&quot; or name =&quot;销售部&quot; 最终的 sql 其实是这样的1select * from emp where dept_id in (1,3) not in 的例子1select * from emp where dept_id not in (select id from dept where name = &quot;财务部&quot; or name =&quot;销售部&quot;) 其实就是上面结果集的取反 exists 例子SQL分析 从 dept 表中查询 id &#x3D; 1 的记录，若有，exists 表达式则返回True 外层查询语句接收到 True 之后，对 emp 表进行查询，返回所有记录 1select * from emp where exists(select * from dept where id = 1) 可以看看 exists 表达式里的子查询结果集1select * from dept where id = 1 可以看到，查询结果集不为空，所以 exists() 返回 true 最终的 sql 其实是这样的1select * from emp where true exists + 其他查询条件1select * from emp where exists (select * from dept where id = 1) and dept_id = 2 知识点 子查询的功能其实通过表连接（join）也可以完成 一般来说，表连接（内连接、外连接等）都可以用子查询查询，但反过来却不一定，有的子查询不能用表连接来替换 子查询比较灵活，适合作为查询的筛选条件 表连接更适合查看连接表之后的数据集 子查询重点子查询语句可以嵌套在 sql 语句中任何表达式出现的位置查询sql 语句的组成一般是这样 1select &lt;字段&gt; from &lt;表名&gt; where &lt;查询条件&gt; 字段、表名、查询条件都可以嵌套子查询！123select &lt;子查询&gt; from &lt;表名&gt; where &lt;查询条件&gt;select &lt;字段&gt; from &lt;子查询&gt; as &lt;别名&gt; where &lt;查询条件&gt;select &lt;字段&gt; from &lt;表名&gt; where &lt;子查询&gt; 常见错误写法1select * from (select * from emp); 这样写是会报错的，因为没有给子查询指定别名 正确写法 1select * from (select * from emp) as t; 注意点如果**&lt;表名&gt;嵌套的是子查询，必须给表指定别名，一般会返回多行多列的结果集，当做一张新的临时表** 只出现在子查询中而没有出现在父查询中的表不能包含在输出列中 多层嵌套子查询的最终结果集只包含父查询（最外层的查询）的select 语句中出现的字段 子查询的结果集通常会作为其外层查询的数据源或用于条件判断 正则查询1&lt;列名&gt; regexp &#x27;正则表达式&#x27; 常用的正则表达式 选项 说明 例子 匹配值示例 ^ 匹配文本的开始字符 ‘^b’ 匹配以字母 b 开头的字符串 book、big、banana、bike $ 匹配文本的结束字符 ‘st$’ 匹配以 st 结尾的字符串 test、resist、persist . 匹配任何单个字符 ‘b.t’ 匹配任何 b 和 t 之间有一个字符 bit、bat、but、bite * 匹配零个或多个在它前面的字符 ‘f*n’ 匹配字符 n 前面有任意个字符 f fn、fan、faan、abcn + 匹配前面的字符 1 次或多次 ‘ba+’ 匹配以 b 开头，后面至少紧跟一个 a ba、bay、bare、battle &lt;字符串&gt; 匹配包含指定字符的文本 ‘fa’ 匹配包含‘fa’的文本 fan、afa、faad [字符集合] 匹配字符集合中的任何一个字符 ‘[xz]’ 匹配 x 或者 z dizzy、zebra、x-ray、extra [^] 匹配不在括号中的任何字符 ‘[^abc]’ 匹配任何不包含 a、b 或 c 的字符串 desk、fox、f8ke 字符串{n,} 匹配前面的字符串至少 n 次 ‘b{2}’ 匹配 2 个或更多的 b bbb、bbbb、bbbbbbb 字符串 {n,m} 匹配前面的字符串至少 n 次， 至多 m 次 ‘b{2,4}’ 匹配最少 2 个，最多 4 个 b bbb、bbbb 例一：^1select * from product where product_name regexp &#x27;^2018&#x27;; 例子二：$1select * from product where product_name regexp &#x27;潮$&#x27;; 例三： *、+po*：查询 name 字段包含字母 p ，且 p 后面出现字母 o 的记录，而 * 可以表示0个字符，代表不出现 1select * from emp where name regexp &#x27;po*&#x27;; po+：查询 name 字段包含字母 p ，且 p 后面出现字母 o 的记录，但 + 表示至少出现1个字符 1select * from emp where name regexp &#x27;po+&#x27;; 例四：[]下面两种写法是一样的，用 , 隔开每个字符，可能可读性更高 12select * from emp where name regexp &#x27;[p,s]&#x27;;select * from emp where name regexp &#x27;[ps]&#x27;; 例子五：[^]注意：这里的^是取反，不是开头的意思哦！不要混淆 查询 id &gt;&#x3D;10 且 开头非字母 p 的记录 1select * from emp where id &gt;=10 and name regexp &#x27;^[^p]&#x27;; 为啥中途换表因为，我发现正则表达式并不是对所有中文都生效，举个下面的例子 1select * from emp where name regexp &#x27;[小]&#x27;; 可以看到，name 字段需要匹配到一个【小】才应该被返回，但是除了红框以外的数据都被返回了，有问题有问题…. 那为什么会这样呢？ 原来，是因为 regexp 不支持多字节匹配，说白了，就是不支持中文编码 要想查询中文，最好通过 like 关键字进行模糊匹配啦 当然啦，也不是没有解决办法只需要用小括号()把中文括起来就行了 1select * from emp where name regexp &#x27;^(小)&#x27;; 但，这种写法在 [ ] 里面还是不起作用 1select * from emp where name regexp &#x27;[(小)]&#x27;; 所以，还是推荐用 like 模糊匹配中文字符吧！而且日常工作中也完全够用啦！","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":"Noir"},{"title":"MySQL-增删改","slug":"MySQL-增删改","date":"2023-06-25T18:47:24.819Z","updated":"2023-06-25T18:53:49.995Z","comments":true,"path":"2023/06/26/MySQL-增删改/","link":"","permalink":"http://example.com/2023/06/26/MySQL-%E5%A2%9E%E5%88%A0%E6%94%B9/","excerpt":"","text":"insert 属于DML语句（数据操纵语句） insert … values语法格式12INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ]VALUES (值1) [… , (值n) ]; 语法格式说明 &lt;列名&gt;：可以不指定，默认指定表的所有列名 values：字段有多少个，值就要有多少个，且顺序要对应，否则会报错 insert .. set语法格式这个用的不多哈，了解为主； 1234INSERT INTO &lt;表名&gt;SET &lt;列名1&gt; = &lt;值1&gt;, &lt;列名2&gt; = &lt;值2&gt;, … 两种语法格式的区别 insert .. values 可以插入任意行数据，而 insert … set 每次只能插入一行数据 例一：不指定字段，添加记录123INSERT INTO empVALUES ( &quot;20&quot;, &quot;员工1&quot;, 3, 1, 1 ); 例二：指定所有字段，添加记录123INSERT INTO emp ( id, NAME, dept_id, leader, is_enable )VALUES ( &quot;20&quot;, &quot;员工1&quot;, 3, 1, 1 ); 上面两个栗子添加的记录数据是一样的哦，只是一个指定了所有字段，另一个是不指定任何字段 知识点 指定多个字段时，字段的顺序可以随意，不需要按照表定义的顺序来写，但要保证 values 的顺序和字段的顺序相同！ 指定的字段不用加单引号或者双引号，否则会报错 常见错误写法特别在写代码的时候，经常需要字符串连接，一不留意就会用引号把字段名括起来，这样是不对的哦！ 123INSERT INTO emp ( &#x27;id&#x27;, &#x27;name&#x27; )VALUES ( &quot;20&quot;, &quot;员工1&quot;); 例三：复制表数据来插入12345678910INSERT INTO emp ( id, NAME, dept_id, leader, is_enable ) SELECT15,NAME,dept_id,leader,is_enable FROM emp WHERE id = 1; 主要的语法格式1insert into &lt;表名&gt; [&lt;字段名&gt;,&lt;字段名&gt;..] select .... 注意：如果是复制表数据的话，不用加 values() ！ 改 - updateupdate 也是DML语句哦（数据操作语言） 语法格式1UPDATE &lt;表名&gt; SET 字段1=值1 [,字段2=值2… ] [WHERE 子句 ] [LIMIT 子句] 语法格式说明 多指定多个字段，需要用 , 隔开 如果修改的字段有默认值，可以用 default 来设置字段的值，如： name &#x3D; default ，这样就会把字段的值修改成默认值 where 就不用多说了，一般 update 数据都会指定条件 添加 limit 是为了限制被修改的行数，加不加都行 修改单个字段1234UPDATE emp SET is_enable = 0 WHERE id = 1 修改多个字段123456UPDATE emp SET is_enable = 0,NAME = &quot;修改的名字&quot;,dept_id = 2 WHERE id = 1 删 - delete语法格式1DELETE FROM &lt;表名&gt; [WHERE 子句] [LIMIT 子句] 语法格式说明 where 就不用多说了，一般 delete 数据都会指定条件 添加 limit 是为了限制被删除的行数，加不加都行 删除表中的全部数据1delete from emp; 根据条件删除表中的数据123456DELETE FROM emp WHERE is_enable = 0 OR is_enable IS NULL;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":"Noir"},{"title":"Linux常用指令","slug":"Linux命令常用指令","date":"2023-06-25T16:18:28.002Z","updated":"2023-06-25T17:29:10.423Z","comments":true,"path":"2023/06/26/Linux命令常用指令/","link":"","permalink":"http://example.com/2023/06/26/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"cd - 切换目录进入上级目录1cd .. 进入当前目录1cd ~ 进入上两级目录1cd ../.. 进入当前目录1cd . 进入指定目录,例&#x2F;usr&#x2F;local1cd /usr/local mkdir - 新建文件夹新建一个文件夹1mkdir 文件夹名 新建三个文件夹1mkdir 文件夹名1 文件夹名2 文件夹名3 新建一个多层文件夹1mkdir -p 11/22/33 新建一个文件夹,并设置权限1mkdir -m 777 文件夹名 mv - 移动移动当前用户文件夹下的test文件夹,到&#x2F;usr&#x2F;local1mv ~/test/ /usr/local 移动文件123.txt ,到&#x2F;usr&#x2F;local1mv 123.txt /usr/local 移动当前目录的123.txt到&#x2F;usr&#x2F;local目录,并重命名为456.txt1mv 123.txt /usr/local/456.txt 移动文件至上级目录1mv 123.txt ../ 移动两个文件到目录 &#x2F;usr&#x2F;local1mv 123.tar.gz 456.tar.gz /usr/local 移动123.txt到usr&#x2F;local下,但目录下已存在123.txt,强制覆盖1mv 123.txt -f /usr/local 移动123.txt到usr&#x2F;local,但目录下已存在123..txt,询问是否覆盖1mv 123.txt -i /usr/local cp - 复制复制文件123.txt到&#x2F;usr&#x2F;local目录1cp 123.txt /usr/local 复制文件夹aaa到&#x2F;usr&#x2F;local目录1cp -r aaa/ /usr/local 复制文件123.txt到&#x2F;usr&#x2F;local,强制覆盖1cp -f 123.txt /usr/local 复制文件123.txt到&#x2F;usr&#x2F;local,询问是否强制覆盖1cp -i 123.txt /usr/local 复制 123.txt到&#x2F;usr&#x2F;local目录.并修改时间和访问权限一起复制1cp -p 123.txt /usr/local history - 查看历史记录查看历史命令执行记录1history 查看命令mkdir 的历史执行记录1history | grep mkdir 执行历史记录中，序号为1015的命令1!1015 执行上一条命令（直接输入两个感叹号）1!! 查找最后10条历史记录（两种方式）12history 10history | tail -10 清除历史记录1history -c 将当前所有历史记录写入历史文件中，默认写入 ~&#x2F;.bash_history12history -wcat ~/.bash_history tar - 解压缩tar后缀文件压缩一个文件123.ini12tar -zcvf 123.tar.gz 123.initar -zcvf 压缩包名.tar.gz 文件名 压缩多个文件123.txt 456.txt1tar -zcvf 压缩包名.tar.gz 123.txt 456.txt 压缩文件夹123&#x2F;1tar -zcvf 压缩包名.tar.gz 123/ 将当前目录,所有指定格式文件打包成123.tar1tar -cvf 123.tar.gz *.png 将当前目录,所有指定格式文件打包成123.tar.gz1tar -zcvf 123.tar.gz *.png 解压123.tar1tar -xvf 123.tar 解压123.tar.gz1tar -zxvf 123.tar.gz tail - 实时刷新文件内容实时刷新log1tail -f test.log 实时刷新最新100条log1tail -100f test.log 显示最后5条log(两种写法)12tail -n 5 test.logtail -5 test.log 显示第10条后面的所有log1tail -n +10 test.log ls - 查看目录文件列出当前目录中所有的子目录和文件(不包含隐藏文件 .开头的)1ls 列出目录下的所有的子目录和文件（包含隐藏文件 .开头的）1ls -a 列出文件的详细信息（包括权限、所有者、文件大小等） 两种方式1ls -lll 列出当前目录中所有以“test”开头的详细内容1ls -l test* 按文件最后修改时间排序，降序1ls -t 按文件大小排序，从大到小1ls -S 查看文件大小时增加可读性（1K 2M 2G）12ls -l -hll -h ps - 查看进程查看所有进程1ps -A 查看java进程1ps -ef | grep java 显示所有进程信息，连同命令行1ps -ef ps 与grep 常用组合用法，查找特定进程1ps -ef | grep java ps -ef返回列表各个字段的含义 UID：表示用户ID PID：表示进程ID PPID：表示父进程号 C：表示CPU的占用率 STIME：进程的启动时间 TTY：登入者的终端机位置 TIME：表示进程执行起到现在总的CPU占用时间 CMD：表示启动这个进程的命令 显示所有进程更详细的信息，包括进程占用CPU、内存1ps -aux 根据CPU、内存使用来降序排序12ps -aux --sort -pcpups -aux --sort -pmem ps -aux返回列表各个字段的含义 USER：表示哪个用户启动了这个进程 PID ：进程ID %CPU：进程CPU的占用率 %MEM：进程物理内存的占用率 VSZ ：进程占用的虚拟内存量 (Kbytes) RSS ：进程当前实际上占用了多少内存 TTY ：进程是在哪个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts&#x2F;0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有 R ：运行；该程序目前正在运作，或者是可被运作 D：不可中断：一般是IO进程 S ：中断；该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。 T ：停止：该程序目前正在侦测或者是停止了 Z ：僵尸：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (僵尸) 程序的状态 START：该进程启动的时间点 TIME ：进程从启动后到现在，实际占用CPU的总时间 COMMAND：启动该进程的命令 USER：表示哪个用户启动了这个进程 PID ：进程ID %CPU：进程CPU的占用率 %MEM：进程物理内存的占用率 VSZ ：进程占用的虚拟内存量 (Kbytes) RSS ：进程当前实际上占用了多少内存 TTY ：进程是在哪个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts&#x2F;0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有 R ：运行；该程序目前正在运作，或者是可被运作 D：不可中断：一般是IO进程 S ：中断；该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。 T ：停止：该程序目前正在侦测或者是停止了 Z ：僵尸：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (僵尸) 程序的状态 START：该进程启动的时间点 TIME ：进程从启动后到现在，实际占用CPU的总时间 COMMAND：启动该进程的命令 top - 资源管工具top的各项指标信息含义可参考此博文：https://www.cnblogs.com/poloyy/p/12552041.html 查看所有进程的资源占用情况1top 监控每个逻辑CPU的状况1top ，按 1 高亮显示当前运行进程1top ，按 b 显示完整命令1top ，按 c 切换显示CPU1top，按t 按CPU使用率从大到小排序1top，按P 切换显示Memory1top，按m 按Memory占用率从大到小排序1top，按M 按累计运行时间Time从大到小排序1top，按T 高亮CPU列1top，按x 彩色高亮显示1top，按ztop，按shift+z 可以调配色方案 通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列1top shift + &gt;或shift + &lt; 忽略闲置和僵死进程，这是一个开关式命令1top，按i 杀掉进程1top，按k，输入PID 改变内存的显示单位，默认为KB1top，按e （针对列表）top，按E （针对头部统计信息） 退出top程序1按 q wget - 下载文件下载isTester.jpg文件1wget http://51.istester.com/isTester.png 下载isTester.jpg文件，并存储名为isTester_Logo.jpg1wget -o isTester_Logo.jpg http://51.istester.com/isTester.png 下载isTester.jpg文件，后台形式下载1wget -b http://51.istester.com/isTester.png rm - 删除删除&#x2F;root&#x2F;yyTest&#x2F;目录下的文件yyTest.ini （系统会询问是否删除）1rm /root/yyTest/yyTest.ini 强行删除&#x2F;root&#x2F;yyTest&#x2F;目录下的文件yyTest.ini（直接删除，系统不会提示）1rm -f /root/yyTest/yyTest.ini 删除&#x2F;root&#x2F;yyTest&#x2F;目录下的所有.log文件1rm -f /root/yyTest/*.log 删除&#x2F;root&#x2F;yyTest&#x2F;目录下的 polo&#x2F;文件夹1rm -r /root/yyTest/polo/ 强行删除&#x2F;root&#x2F;yyTest&#x2F;目录下的 polo&#x2F;文件夹1rm -rf /root/yyTest/polo/ 删除&#x2F;root&#x2F;yyTest&#x2F;目录下的所有内容1rm -rf /root/yyTest/* touch - 创建文件创建一个文件1touch yyTest.ini 同时创建两个文件1touch test1.txt test2.txt 批量创建文件（如创建2000个文件）1touch test&#123;0001..2000&#125;.txt 更改文件 yyTest.ini时间为当前时间（yyTest.ini已存在）1touch yyTest.ini vi和vim12vi test.txtvim touch.txt &gt;、&gt;&gt; - 重定向&gt;直接覆盖原文件，不会有任何提示 &gt;&gt;追加在原文件末尾，不会覆盖原文件的内容 直接用&gt;创建空文件1&gt; test.ini ls 创建文件（将结果写入文件）12ls &gt; test.inils &gt;&gt; test.ini grep 创建文件（将结果写入文件）12ps -ef | grep java &gt;test.inips -ef | grep java &gt;&gt;test.ini echo 创建文件（将结果写入文件）12echo $PATH &gt; test.iniecho $PATH &gt;&gt; test.ini 使用cat创建文件简单使用&gt;、&gt;&gt;12cat &gt; test.inicat &gt;&gt; test.ini 其实用的也是 &gt; 和 &gt;&gt; ，但是有一点不一样的是，敲完上述命令会进入 test.ini 的编辑模式，可以直接输入你想要写入的内容，最后按ctrl+z退出编辑模式自动保存 cat结合eof12345cat &gt;&gt; test.ini &lt;&lt;eof222eof eof可以作为一个分界符，遇到下一个分界符时停止输入；大小写一样的哦 cat结合exit和eof同理 1234cat &gt;&gt; test.ini &lt;&lt;exit11exit head - 显示文件前*行显示文件的前5行（两种方式）12head -n 5 test.txthead -5 test.txt 显示文件的前100个字符1head -c 100 test.txt 显示文件的第10-20行1head -20 test.txt | tail -10 cat - 查看文件内容获取test.txt文件所有内容1cat test.txt 无论是否为空行，都显示行号1cat -n test.txt 显示行号，除了空行1cat -b test.txt 连续读取两个文件，按顺序输出1cat test1.txt test2.txt 倒序输出其实就是cat倒过来写即可 1tac test.txt more - 查看文件内容每次显示5行1more -5 test.txt 从第5行开始显示1more +5 test.txt 每次翻页时，先清空屏幕内容1more -5 -p test.txt 若遇到连续两行以上的空白行，合并为一行空白行1more -s test.txt 执行more命令后，常用的操作向下滚动一屏123z空格键ctrl+f 向上滚动一屏12bctrl+b 输出文件名和当前行的行号1:f 进入vim编辑器1v 退出more模式1q less - 查看文件内容查看文件1less test.txt ps查看进程并通过less分页显示1ps -ef | less 显示当前行数的百分比1less -m test.txt 显示当前行数&#x2F;总行数和百分比1less -M test.txt 显示连续空行为一行1less -s test.txt 进入less模式之后的操作g：移动到第一行 G：移动到最后一行 u：向前移动半屏 d：向后移动半屏 f：向后移动指定行数或一屏 b：向前移动指定行数或一屏 j：向下移动一行 k：向上移动一行 q：结束less模式 nl - 显示行号显示行号，除了空行默认就是这个 12nl test.txtnl -b t test.txt 无论是否为空行，都显示行号1nl -b a test.txt 行号靠最左显示1nl -n ln test.txt 行号靠最右显示1nl -n rn test.txt 行号靠最右显示，不足位数左边补01nl -n rz test.txt find - 查找命令最基础的打印操作1find ~/test 知识点 -print 是默认就有的，不写也可以，而 -print 默认是以 \\n 来分隔找到的文件 如果不想换行打印，可以考虑空格分隔，加上 -print0 即可 1find ~/test -print0 通过文件名搜索 -name：仅可以对文件的file_name匹配 -path：可以对文件的dir_name、file_name匹配 查找的文件名最好使用引号包围，可以配合通配符进行查找 查找~&#x2F;test下的.txt文件1find ~/test -name &quot;*.txt&quot; 在~&#x2F;test下查找cool文件夹下的.txt文件1find ~/test -path &quot;/*cool*/*.txt&quot; 倘若，我们通过-name来执行会是怎么样的呢？是会报错的因为 -name 是不能使用 &#x2F; 的，除非文件名包含了 &#x2F; ， 因为 -name 只能匹配 file_name （即文件名），并不匹配 dir_name （即目录名） 所以想要在指定目录（**~&#x2F;test）下搜索某目录中（&#x2F;cool）的某文件（.txt），应该使用-path而不是-name** 通过文件的类型来搜索在~&#x2F;test目录下查找所有的目录1find ~/test -type d 在~&#x2F;test目录下查找所有的文件1find ~/test -type f 还有其他不常用的文件类型 b：块设备 c：字符设备 p：管道 l：符号链接 通过文件的时间来搜索在~&#x2F;test目录下查找修改时间在5日以内的文件1find ~/test -mtime -5 在~&#x2F;test目录下查找修改时间在3日以前的.txt文件1find ~/test -type f -name &quot;*.txt&quot; -mtime +3 在~&#x2F;test目录下查找更改时间在5分钟以内的.txt文件1find ~/test -type f -name &quot;*.txt&quot; -mmin -5 在~&#x2F;test目录下查找修改时间在10分钟以前的文件1find ~/test -mmin +10 注意点 Linux的文件有三种时间类型，具体可看此文章：https://www.cnblogs.com/poloyy/p/12586677.html 无论是 -mtime +5 还是 -mtime -5 ，第五天内修改过的文件都不会被搜索出来，可看下图 通过文件的大小来搜索语法格式1-size n[cwbkMG] 那么它有什么类型大小单位呢？（官方直接给了答案）b：512字节的块（默认），1b &#x3D; 512c c：bytes，指定字节大小 w：等价于两个bytes，1w&#x3D;2c，一般用户匹配中文 k：平时常说的1kb，1k&#x3D;1024c&#x3D;2b M：1MB，1M&#x3D;1024k&#x3D;2048b G：1GB，1GB&#x3D;1024MB&#x3D;2048*1024b 在~&#x2F;test目录下查找所有size&#x3D;0字节的文件1find ~/test -size 0 在~&#x2F;test目录下查找所有size&lt;100k的文件1find ~/test -size -100k 在~&#x2F;test目录下查找所有size&gt;1MB的文件1find ~/test -size +1M 通过编程中的“与、或、非”来搜索 -a：与，即&amp;&amp;（默认都是与） -o：或：即|| -not：非，即条件结果取反 在~&#x2F;test目录下查找文件大小在1kb和10kb内的所有文件12find ~/test -size +1k -size -10kfind ~/test -size +1k -a -size -10k 在~&#x2F;test目录下查找大于1kb或类型为普通文件的文件1find ~/test -size +1k -o -type f 在~&#x2F;test目录下查找非空文件1find ~/test -not -size 0 在~&#x2F;test目录下查找文件或目录1find ~/test -type f -o -type d 搜索空文件1find ~/test -empty -type f 通过文件所属用户搜索1find ~/test -user root 通过文件所属组group搜索1find ~/test -group root fuser - 断开终端连接命令作用有三种解释 使用文件或 socket 识别进程 显示哪些进程使用命名文件、socket 或文件系统 显示使用指定文件或文件的进程的 pid 系统 总的来说就是文件+进程 语法格式fuser [-fMuvw] [-a|-s] [-4|-6] [-c|-m|-n SPACE] [-k [-i] [-SIGNAL]] NAME… 参数列表 参数 作用 -a,–all 显示未使用的文件 -i,–interactive 杀死前的交互式询问（忽略而不使用-k） -k,–kill 终止访问命名文件的进程 -l,–list 列出可用的信号名称 -m,–mount 显示使用命名文件系统或块设备的所有进程 -M,–ismountpoint 仅当NAME是挂载点时满足请求 -n,–namespace 在此名称空间中搜索命名空间（文件、udp或tcp） -s,–silent 静默操作 -SIGNAL 发送这个信号而不是SIGKILL -u,–user 显示用户ID -v,–verbose 详细输出 -w,–writeonly 杀死具有写访问权限的进程 -V,–version 版本信息 -4,–ipv4 搜索ipv4 socket -6,–ipv6 搜索ipv6 socket - reset 重置 基础用法1fuser /root PID后跟的字符说明了进程以何种方式与该目录&#x2F;文件关联 c 指示进程的工作目录 e 指示该文件为进程的可执行文件(即进程由该文件拉起) f 指示该文件被进程打开，默认情况下f字符不显示 F 指示该文件被进程打开进行写入，默认情况下F字符不显示 r 指示该目录为进程的根目录 m 指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存 . 占位符，默认显示模式中省略 详细输出1fuser -v /root 杀掉进程1fuser -k /dev/pts/0 这是断开本地 ssh 连接阿里云服务器的终端 杀掉进程并询问1fuser -v -i -k /dev/pts/0 last - 查看上次登录用户的列表命令作用 显示上次登录用户的列表 这个是在 Linux 下的 last 命令，跟 Mac 下有点不同 语法格式1last [options] [&lt;username&gt;...] [&lt;tty&gt;...] 参数说明 参数 含义 - 显示多少行 -a, –hostlast last在最后一列中显示主机名 -d, –dns 将IP号转换回主机名 -f, –file &lt;读取特定文件而不是 &#x2F;var&#x2F;log&#x2F;wtmp -F, –fulltimes 打印完整的登录和注销时间和日期 -i, –ip 以数字和点表示法显示ip编号 -n, –limit 限制要显示的行数 -R, –nohostname 不显示hostname字段 -s, –since 显示指定时间以来的行 -t, –until 显示指定时间之前的行 -p, –present 显示在指定时间出现的人员 -w, –fullnames 显示完整的用户名和域名 -x, –system 显示系统关闭条目和运行级别更改 -h, –help 帮助 -V, –version 版本 查看列表说明 第一列：用户名 第二列：终端位置，pts&#x2F;0 (伪终端) 意味着从 SSH 或 telnet 的远程连接的用，.tty (teletypewriter) 意味着直接连接到计算机或者本地连接的用户 第三列：登录的 IP 或终端名，用户通过本地终端连接则显示空，除了重启活动，内核版本会显示在状态中 第四列：登录开始时间 第五列：结束时间 第六列：持续时间，still logged in 表示仍然在线 显示5行，将 host 放在最后一列，打印完整的时间日期，并将 ip 转成主机名1last -5 -a -d -F 不显示 hostname1last -R 显示5行，显示完整的用户名和主机名，并只显示从 2021-06-04 17:33:00 开始到现在的信息1last -5 -w -s 202106041733300 显示5行，并只显示在 2021-06-06 00:00:00 之前的信息1last -5 -t 20210606000000 last 命令的数据源执行 last 命令时，默认读取 &#x2F;var&#x2F;log&#x2F;wtmp 文件 它是一个二进制文件，记录每个用户的登录系统次数和持续时间、注销、系统重启、停机等事件 它是永久记录这些信息的，系统运行时间增加，文件也会越来越大 因为它本身是一个二进制文件，所以无法直接 cat 查看，因此诞生了 last 命令来查看 还有另外一个命令，lastb 它是读取 &#x2F;var&#x2F;log&#x2F;btmp 文件，记录登录系统失败的每个用户 当然，用 last -f 读取这个文件也是一样效果的 &#x2F;var&#x2F;run&#x2F;utmp 它比较重要，记录着当前正在登录系统的每个用户 它的数据结构和 &#x2F;var&#x2F;log&#x2F;wtmp 的数据结构一样 &#x2F;var&#x2F;log&#x2F;lastlog 记录着每个用户最后登录系统的信息 它的数据结构和 &#x2F;var&#x2F;run&#x2F;utmp 、 &#x2F;var&#x2F;log&#x2F;wtmp 不一样 last -f &#x2F;var&#x2F;log&#x2F;wtmp1last -f /var/log/wtmp last -f &#x2F;var&#x2F;log&#x2F;btmp1last -f /var/log/btmp 和 lastb 查出来用户列表信息是一样的 本地用户直接 ssh 登阿里云 因为阿里云没有 polo 这个用户，所以连不上 然后系统就自动记录 polo 用户登录系统失败了 last -f &#x2F;var&#x2F;run&#x2F;utmp1last -f /var/run/utmp 当前就一个 root 用户登录，加上一个系统信息 last -f &#x2F;var&#x2F;log&#x2F;lastlog1last -f /var/log/lastlog 直接用 last -f 好像并不会显示信息，应该是因为读取的文件的数据结构不一致的原因 lastlog1lastlog 后面查了下，可以直接用 lastlog 查看 &#x2F;var&#x2F;log&#x2F;lastlog 实际工作场景：因为某些用户的链接数太多导致无法再连接，此时需要断开用户已存在的终端链接通过 last 找到用户的终端信息，然后用 fuser kill 掉 12lastfuser -k /dev/pts/0 这里就踩了个坑，如果直接敲 pts&#x2F;0 会报错， 因为路径不对，需要加上根路径 &#x2F;dev&#x2F;pts&#x2F;0 杀掉当前终端链接文件后，我的 ssh 连接就自动退掉了 重新 ssh 连接服务器，查看之前的登录信息 通过 fuser 批量杀掉同一个用户的终端链接1fuser -k $(last -w | grep name | awk &#x27;&#123;print &quot;/dev/&quot;$2&#125;&#x27;) 自己换掉 name 直接 ps -ef 去删掉1ps -ef|grep name | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9 curl - 调试接口命令 curl 是常用的命令行工具，用来请求 Web 服务器 它的名字就是客户端（client）的 URL 工具的意思 它的功能非常强大，命令行参数多达几十种 如果熟练的话，完全可以取代 Postman 接口测试工具 官方文档https://curl.se/docs/manpage.html 支持的协议 DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS IMAP、IMAPS、LDAP、LDAP、POP3、POP3、RTMP、RTSP、SCP、SFTP、SMB SMBS、SMTP、SMTPS、TELNET、TFTP 提供强大的功能 代理支持 用户身份验证 FTP上传 httppost SSL连接 cookies 文件传输恢复 Metalink 等等 语法格式1curl [options / URLs] 内容较多请查看这篇文章:https://www.cnblogs.com/poloyy/p/14854183.html 其他指令下载或者上传需要软件安装包下载:1yum 上传:12scpsz 修改文件内容:1vi 修改权限:1chmod 应用配置:1source 配置文件名 安装项目, 运行并测试访问(1)初始化数据库接口及基本数据1.由开发提供数据库初始化脚本(一般以 xxx.sql 结尾) 2.命令行连接到数据库命令格式 1mysql -u用户名 -p密码 3.初始化数据库结构与基本数据命令格式 1source xxx.sql (2)启动项目以 Java 程序为例命令格式 1java -jar 程序名.jar grep - 查找关键字grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。 语法123grep [options] pattern [files]或grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...] pattern - 表示要查找的字符串或正则表达式。 files - 表示要查找的文件名，可以同时查找多个文件，如果省略 files 参数，则默认从标准输入中读取数据。 常用选项：： -i：忽略大小写进行匹配。 -v：反向查找，只打印不匹配的行。 -n：显示匹配行的行号。 -r：递归查找子目录中的文件。 -l：只打印匹配的文件名。 -c：只打印匹配的行数。 更多参数说明： -a 或 –text : 不要忽略二进制的数据。 -A&lt;显示行数&gt; 或 –after-context&#x3D;&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; 或 –before-context&#x3D;&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c 或 –count : 计算符合样式的列数。 -C&lt;显示行数&gt; 或 –context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; 或 –directories&#x3D;&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; 或 –regexp&#x3D;&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。 -E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。 -f&lt;规则文件&gt; 或 –file&#x3D;&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 –fixed-regexp : 将样式视为固定字符串的列表。 -G 或 –basic-regexp : 将样式视为普通的表示法来使用。 -h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 –ignore-case : 忽略字符大小写的差别。 -l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。 -L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。 -n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 –only-matching : 只显示匹配PATTERN 部分。 -q 或 –quiet或–silent : 不显示任何信息。 -r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。 -s 或 –no-messages : 不显示错误信息。 -v 或 –invert-match : 显示不包含匹配文本的所有行。 -V 或 –version : 显示版本信息。 -w 或 –word-regexp : 只显示全字符合的列。 -x –line-regexp : 只显示全列符合的列。 -y : 此参数的效果和指定”-i”参数相同。 实例1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行： 1grep hello file.txt 2、在文件夹 dir 中递归查找所有文件中匹配正则表达式 “pattern” 的行，并打印匹配行所在的文件名和行号： 1grep -r -n pattern dir/ 3、在标准输入中查找字符串 “world”，并只打印匹配的行数： 1echo &quot;hello world&quot; | grep -c world 4、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： 1grep test *file 结果如下所示： 1234$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件 testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行 testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行 testfile_2:Linux test #列出testfile_2 文件中包含test字符的行 5、以递归的方式查找符合条件的文件。例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为： 1grep -r update /etc/acpi 输出结果如下： 1234567$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi” #下包含“update”的文件 /etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than /etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than /etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update 6、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。 查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为： 1grep -v test *test* 结果如下所示： 123456789$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行 testfile1:helLinux! testfile1:Linis a free Unix-type operating system. testfile1:Lin testfile_1:HELLO LINUX! testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM. testfile_1:THIS IS A LINUX TESTFILE! testfile_2:HELLO LINUX! testfile_2:Linux is a free unix-type opterating system. Linux 命令大全","categories":[{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/categories/Liunx/"}],"tags":[{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/tags/Liunx/"}],"author":"Noir"},{"title":"selenium常见用法","slug":"selenium常见交互","date":"2023-06-17T09:47:43.314Z","updated":"2023-06-19T11:21:26.518Z","comments":true,"path":"2023/06/17/selenium常见交互/","link":"","permalink":"http://example.com/2023/06/17/selenium%E5%B8%B8%E8%A7%81%E4%BA%A4%E4%BA%92/","excerpt":"","text":"selenium常见用法点击+输入+清空1234561. 元素点击element.click()2. 输入element.send_keys(内容)3. 清除element.clear() 大小&#x2F;文本&#x2F;属性1234561. 大小element.size2. 文本element.text3. 属性element.get_attribute(&#x27;属性名&#x27;) 判断元素是否可见123element.is_displayed()可见 : True不可见: False 判断元素是否可用12345简单的理解,可以认为是是否可以点击element.is_enabled()可用: True不可用: False 判断元素是否被选中123element.is_selected()选中: True未选中: False 浏览器常见的操作设置浏览器显示范围1234561. 窗口最大化 -- 重点driver.maximize_window() 2. 设置窗口大小dirver.set_window_size(width, height)3. 设置窗口位置dirver.set_window_position(x, y) 浏览器显示页面操作1234561. 页面后退操作driver.back()2. 页面前置操作driver.forword()3. 刷新driver.refresh() -- 重点 关闭窗口&#x2F;关闭浏览器12341. 关闭当前窗口driver.close() 关闭当前窗口2. 关闭浏览器driver.quit() 不管有多少个打开的窗口,都会直接关闭退出 获取标题&#x2F;URL123456作为页面断言的内容使用1. 标题driver.title2. URLdriver.current_url 下拉框 12345678910111. 在 HTML 页面中, 可以下拉选择内容的的称为是下拉框2. 下拉框的标准实现是 select 标签和 option 结合3. 下拉框中的内容是可以直接使用 元素定位的4. 如果,下拉框是 select 实现的, 推荐使用 selenium 中提供的方法去操作- 1. 创建Select 类(selenium 提供的)的对象- 对象 = Select(元素对象)- 2. 通过对象选择下拉框中的内容即可- - 对象.select_by_index(index) 根据索引选择, 从 0 开始- - 对象.select_by_value(value) 根据 value 属性值选择- - 对象.select_by_visible_text(text) # 根据文本内容选择 弹出框 12345678910111213141, 弹出框分为自定义弹出框 和 JS 弹出框2, 区分方式: 根据是否可以右键检查元素来区分, 如果可以检查元素, 就是自定义弹出框, 如果不能检查元素,就是 JS 弹出框3. 自定义弹出框的处理方式: 直接元素定位解决4. JS 弹出框的处理(alert(警告框)、confirm(确认框)、 prompt(提示框)), 这三种 JS 弹出框的处理方案是一样的.- 1. 获取弹出框对象: 对象 = driver.switch_to.alert- 2. 对弹出框进行处理:- - 确认: 对象.accept()- - 取消: 对象.dismiss()- 其他操作: 获取弹出框的内容 对象.text- prompt 提示框,输入内容,使用的也是 对象.send_keys()注意：在处理弹出框或者具有动画效果的页面，先等待页面加载完成后，再进行操作先等待几秒，在进行页面操作 滚动条123451, selenium 没有提供 直接操作滚动条的方法2, JS(javascript) 是可以 操作滚动条 js = &quot;window.scrollTo(x,y)&quot;3, selenium 提供的操作 JS 代码的方法 driver.execute_script(js) 鼠标操作1234567891011120. # 导包from selenium.webdriver import ActionChains1. 实例化鼠标对象mouse = ActionChains(driver)2. 书写要进行的鼠标操作mouse.操作()- move_to_element(元素对象) 鼠标悬停- context_click(元素对象) 鼠标右击- double_click(元素对象) 鼠标双击(选中)- drag_and_drop(开始元素对象, 结束元素对象) 拖拽3. 执行鼠标动作(必须有执行)mouse.perform() 鼠标悬停、鼠标右键、鼠标双击123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 1) 将鼠标悬停在 注册按钮上# 1, 实例化对象# action = ActionChains(driver)## # 2, 书写鼠标操作# action.move_to_element(driver.find_element(By.TAG_NAME, &#x27;button&#x27;))# # # 3, 执行鼠标操作# action.perform()# 导包import timefrom selenium import webdriver# 获取浏览器驱动对象from selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()# 打开注册A页面driver.get(&quot;http://121.43.169.97:8848/pageA.html&quot;)# 设置浏览器最大化driver.maximize_window()# 定位用户名输入框userA = driver.find_element(By.ID, &quot;userA&quot;)# 创建ActionChains 对象 actionaction = ActionChains(driver)# action调用鼠标右键的方法userA.send_keys(&quot;haha&quot;)action.context_click(userA).pause(2).double_click()# 调用perform方法time.sleep(2)action.perform()# 用户名输入 admintime.sleep(2)userA.send_keys(&quot;admin&quot;)# action调用鼠标双击方法action.double_click(userA)# 调用performtime.sleep(2)action.perform()# 3秒后关闭浏览器窗口time.sleep(5)driver.quit() 鼠标拖拽12345678910# 定位元素 div1 div2 用户拖拽div1 = driver.find_element(By.ID, &quot;div1&quot;)div2 = driver.find_element(By.ID, &quot;div2&quot;)# 创建 ActionChains对象action = ActionChains(driver)# action 调用 拖拽方法action.drag_and_drop(div1, div2)# action 调用 perform函数action.perform()","categories":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"selenium","slug":"selenium","permalink":"http://example.com/tags/selenium/"}],"author":"Noir"}],"categories":[{"name":"ADB","slug":"ADB","permalink":"http://example.com/categories/ADB/"},{"name":"Fiddler","slug":"Fiddler","permalink":"http://example.com/categories/Fiddler/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/categories/Liunx/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"http://example.com/tags/ADB/"},{"name":"APP","slug":"APP","permalink":"http://example.com/tags/APP/"},{"name":"Fiddler","slug":"Fiddler","permalink":"http://example.com/tags/Fiddler/"},{"name":"自动化","slug":"自动化","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://example.com/tags/appium/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/tags/Liunx/"},{"name":"selenium","slug":"selenium","permalink":"http://example.com/tags/selenium/"}]}