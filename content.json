{"meta":{"title":"Noir's Blog","subtitle":"","description":"Noir的博客","author":"Noir","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-06-17T18:58:20.973Z","updated":"2023-06-17T18:58:20.973Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"联系我 邮箱:&#x6e;&#111;&#x69;&#x72;&#x70;&#x75;&#x70;&#x69;&#x6c;&#x6c;&#x65;&#x73;&#97;&#105;&#x73;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#109; 错误指正 关于本站仅作为个人存放日常学习资料和遇到的问题总结,由于本人水平有限,且部分老的博文是在尚不成熟时写的,故难免会存在过时内容或错误.如有发现,请直接在评论区指正."},{"title":"所有分类","date":"2023-06-19T11:34:46.336Z","updated":"2023-06-19T11:34:46.336Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-06-18T10:44:14.617Z","updated":"2023-06-18T10:44:14.617Z","comments":true,"path":"custom/darkmode.css","permalink":"http://example.com/custom/darkmode.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label { color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer { background-color: #292a2d; } .DarkMode strong, .DarkMode img { filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky { background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before { opacity: 1 } .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"archives","date":"2023-06-17T13:45:05.000Z","updated":"2023-06-17T14:57:39.589Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-06-18T10:44:03.527Z","updated":"2023-06-18T10:44:03.527Z","comments":true,"path":"custom/darkmode.js","permalink":"http://example.com/custom/darkmode.js","excerpt":"","text":"function BackTOP() { $(\"#btn\").hide(); $(function () { $(window).scroll(function () { if ($(window).scrollTop() > 50) { $(\"#btn\").fadeIn(200); } else { $(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); $(function () { $(\"#say\").click(function () { $('body,html').animate({ scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () { $('body').toggleClass('read-mode') }) function SiderMenu() { $('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() { $('').appendTo($(\"body\")), setTimeout( function () { (volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () { $(\".Cuteen_DarkSky\").fadeOut(1e3, function () { $(this).remove() }) }, 2e3) }), 50 } function checkNightMode() { if ($(\"html\").hasClass(\"n-f\")) { $(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) { $(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") { $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else { $(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); window.addEventListener('load', ()=>{ volantis.dark.push(()=>{ switchNightMode(); }) }, {once: true})"},{"title":"所有标签","date":"2023-06-19T11:35:13.399Z","updated":"2023-06-19T11:35:13.399Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-06-17T19:02:28.248Z","updated":"2023-06-17T19:02:28.248Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"友链暂不开放哦!!","text":"友链暂不开放哦!!"}],"posts":[{"title":"Linux常用指令","slug":"Linux命令常用指令","date":"2023-06-25T16:18:28.002Z","updated":"2023-06-25T16:18:06.060Z","comments":true,"path":"2023/06/26/Linux命令常用指令/","link":"","permalink":"http://example.com/2023/06/26/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"目录[1. cd - 切换目录] (#1) ## cd - 切换目录 进入上级目录1cd .. 进入当前目录1cd ~ 进入上两级目录1cd ../.. 进入当前目录1cd . 进入指定目录,例&#x2F;usr&#x2F;local1cd /usr/local mkdir - 新建文件夹新建一个文件夹1mkdir 文件夹名 新建三个文件夹1mkdir 文件夹名1 文件夹名2 文件夹名3 新建一个多层文件夹1mkdir -p 11/22/33 新建一个文件夹,并设置权限1mkdir -m 777 文件夹名 mv - 移动移动当前用户文件夹下的test文件夹,到&#x2F;usr&#x2F;local1mv ~/test/ /usr/local 移动文件123.txt ,到&#x2F;usr&#x2F;local1mv 123.txt /usr/local 移动当前目录的123.txt到&#x2F;usr&#x2F;local目录,并重命名为456.txt1mv 123.txt /usr/local/456.txt 移动文件至上级目录1mv 123.txt ../ 移动两个文件到目录 &#x2F;usr&#x2F;local1mv 123.tar.gz 456.tar.gz /usr/local 移动123.txt到usr&#x2F;local下,但目录下已存在123.txt,强制覆盖1mv 123.txt -f /usr/local 移动123.txt到usr&#x2F;local,但目录下已存在123..txt,询问是否覆盖1mv 123.txt -i /usr/local cp - 复制复制文件123.txt到&#x2F;usr&#x2F;local目录1cp 123.txt /usr/local 复制文件夹aaa到&#x2F;usr&#x2F;local目录1cp -r aaa/ /usr/local 复制文件123.txt到&#x2F;usr&#x2F;local,强制覆盖1cp -f 123.txt /usr/local 复制文件123.txt到&#x2F;usr&#x2F;local,询问是否强制覆盖1cp -i 123.txt /usr/local 复制 123.txt到&#x2F;usr&#x2F;local目录.并修改时间和访问权限一起复制1cp -p 123.txt /usr/local history - 查看历史记录查看历史命令执行记录1history 查看命令mkdir 的历史执行记录1history | grep mkdir 执行历史记录中，序号为1015的命令1!1015 执行上一条命令（直接输入两个感叹号）1!! 查找最后10条历史记录（两种方式）12history 10history | tail -10 清除历史记录1history -c 将当前所有历史记录写入历史文件中，默认写入 ~&#x2F;.bash_history12history -wcat ~/.bash_history tar - 解压缩tar后缀文件压缩一个文件123.ini12tar -zcvf 123.tar.gz 123.initar -zcvf 压缩包名.tar.gz 文件名 压缩多个文件123.txt 456.txt1tar -zcvf 压缩包名.tar.gz 123.txt 456.txt 压缩文件夹123&#x2F;1tar -zcvf 压缩包名.tar.gz 123/ 将当前目录,所有指定格式文件打包成123.tar1tar -cvf 123.tar.gz *.png 将当前目录,所有指定格式文件打包成123.tar.gz1tar -zcvf 123.tar.gz *.png 解压123.tar1tar -xvf 123.tar 解压123.tar.gz1tar -zxvf 123.tar.gz tail - 实时刷新文件内容实时刷新log1tail -f test.log 实时刷新最新100条log1tail -100f test.log 显示最后5条log(两种写法)12tail -n 5 test.logtail -5 test.log 显示第10条后面的所有log1tail -n +10 test.log ls - 查看目录文件列出当前目录中所有的子目录和文件(不包含隐藏文件 .开头的)1ls 列出目录下的所有的子目录和文件（包含隐藏文件 .开头的）1ls -a 列出文件的详细信息（包括权限、所有者、文件大小等） 两种方式1ls -lll 列出当前目录中所有以“test”开头的详细内容1ls -l test* 按文件最后修改时间排序，降序1ls -t 按文件大小排序，从大到小1ls -S 查看文件大小时增加可读性（1K 2M 2G）12ls -l -hll -h ps - 查看进程查看所有进程1ps -A 查看java进程1ps -ef | grep java 显示所有进程信息，连同命令行1ps -ef ps 与grep 常用组合用法，查找特定进程1ps -ef | grep java ps -ef返回列表各个字段的含义 UID：表示用户ID PID：表示进程ID PPID：表示父进程号 C：表示CPU的占用率 STIME：进程的启动时间 TTY：登入者的终端机位置 TIME：表示进程执行起到现在总的CPU占用时间 CMD：表示启动这个进程的命令 显示所有进程更详细的信息，包括进程占用CPU、内存1ps -aux 根据CPU、内存使用来降序排序12ps -aux --sort -pcpups -aux --sort -pmem ps -aux返回列表各个字段的含义 USER：表示哪个用户启动了这个进程 PID ：进程ID %CPU：进程CPU的占用率 %MEM：进程物理内存的占用率 VSZ ：进程占用的虚拟内存量 (Kbytes) RSS ：进程当前实际上占用了多少内存 TTY ：进程是在哪个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts&#x2F;0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有 R ：运行；该程序目前正在运作，或者是可被运作 D：不可中断：一般是IO进程 S ：中断；该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。 T ：停止：该程序目前正在侦测或者是停止了 Z ：僵尸：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (僵尸) 程序的状态 START：该进程启动的时间点 TIME ：进程从启动后到现在，实际占用CPU的总时间 COMMAND：启动该进程的命令 USER：表示哪个用户启动了这个进程 PID ：进程ID %CPU：进程CPU的占用率 %MEM：进程物理内存的占用率 VSZ ：进程占用的虚拟内存量 (Kbytes) RSS ：进程当前实际上占用了多少内存 TTY ：进程是在哪个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts&#x2F;0 等等的，则表示为由网络连接进主机的程序。 STAT：该程序目前的状态，主要的状态有 R ：运行；该程序目前正在运作，或者是可被运作 D：不可中断：一般是IO进程 S ：中断；该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。 T ：停止：该程序目前正在侦测或者是停止了 Z ：僵尸：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (僵尸) 程序的状态 START：该进程启动的时间点 TIME ：进程从启动后到现在，实际占用CPU的总时间 COMMAND：启动该进程的命令 top - 资源管工具top的各项指标信息含义可参考此博文：https://www.cnblogs.com/poloyy/p/12552041.html 查看所有进程的资源占用情况1top 监控每个逻辑CPU的状况1top ，按 1 高亮显示当前运行进程1top ，按 b 显示完整命令1top ，按 c 切换显示CPU1top，按t 按CPU使用率从大到小排序1top，按P 切换显示Memory1top，按m 按Memory占用率从大到小排序1top，按M 按累计运行时间Time从大到小排序1top，按T 高亮CPU列1top，按x 彩色高亮显示1top，按ztop，按shift+z 可以调配色方案 通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列1top shift + &gt;或shift + &lt; 忽略闲置和僵死进程，这是一个开关式命令1top，按i 杀掉进程1top，按k，输入PID 改变内存的显示单位，默认为KB1top，按e （针对列表）top，按E （针对头部统计信息） 退出top程序1按 q wget - 下载文件下载isTester.jpg文件1wget http://51.istester.com/isTester.png 下载isTester.jpg文件，并存储名为isTester_Logo.jpg1wget -o isTester_Logo.jpg http://51.istester.com/isTester.png 下载isTester.jpg文件，后台形式下载1wget -b http://51.istester.com/isTester.png rm - 删除删除&#x2F;root&#x2F;yyTest&#x2F;目录下的文件yyTest.ini （系统会询问是否删除）1rm /root/yyTest/yyTest.ini 强行删除&#x2F;root&#x2F;yyTest&#x2F;目录下的文件yyTest.ini（直接删除，系统不会提示）1rm -f /root/yyTest/yyTest.ini 删除&#x2F;root&#x2F;yyTest&#x2F;目录下的所有.log文件1rm -f /root/yyTest/*.log 删除&#x2F;root&#x2F;yyTest&#x2F;目录下的 polo&#x2F;文件夹1rm -r /root/yyTest/polo/ 强行删除&#x2F;root&#x2F;yyTest&#x2F;目录下的 polo&#x2F;文件夹1rm -rf /root/yyTest/polo/ 删除&#x2F;root&#x2F;yyTest&#x2F;目录下的所有内容1rm -rf /root/yyTest/* touch - 创建文件创建一个文件1touch yyTest.ini 同时创建两个文件1touch test1.txt test2.txt 批量创建文件（如创建2000个文件）1touch test&#123;0001..2000&#125;.txt 更改文件 yyTest.ini时间为当前时间（yyTest.ini已存在）1touch yyTest.ini vi和vim12vi test.txtvim touch.txt &gt;、&gt;&gt; - 重定向&gt;直接覆盖原文件，不会有任何提示 &gt;&gt;追加在原文件末尾，不会覆盖原文件的内容 直接用&gt;创建空文件1&gt; test.ini ls 创建文件（将结果写入文件）12ls &gt; test.inils &gt;&gt; test.ini grep 创建文件（将结果写入文件）12ps -ef | grep java &gt;test.inips -ef | grep java &gt;&gt;test.ini echo 创建文件（将结果写入文件）12echo $PATH &gt; test.iniecho $PATH &gt;&gt; test.ini 使用cat创建文件简单使用&gt;、&gt;&gt;12cat &gt; test.inicat &gt;&gt; test.ini 其实用的也是 &gt; 和 &gt;&gt; ，但是有一点不一样的是，敲完上述命令会进入 test.ini 的编辑模式，可以直接输入你想要写入的内容，最后按ctrl+z退出编辑模式自动保存 cat结合eof12345cat &gt;&gt; test.ini &lt;&lt;eof222eof eof可以作为一个分界符，遇到下一个分界符时停止输入；大小写一样的哦 cat结合exit和eof同理 1234cat &gt;&gt; test.ini &lt;&lt;exit11exit head - 显示文件前*行显示文件的前5行（两种方式）12head -n 5 test.txthead -5 test.txt 显示文件的前100个字符1head -c 100 test.txt 显示文件的第10-20行1head -20 test.txt | tail -10 cat - 查看文件内容获取test.txt文件所有内容1cat test.txt 无论是否为空行，都显示行号1cat -n test.txt 显示行号，除了空行1cat -b test.txt 连续读取两个文件，按顺序输出1cat test1.txt test2.txt 倒序输出其实就是cat倒过来写即可 1tac test.txt more - 查看文件内容每次显示5行1more -5 test.txt 从第5行开始显示1more +5 test.txt 每次翻页时，先清空屏幕内容1more -5 -p test.txt 若遇到连续两行以上的空白行，合并为一行空白行1more -s test.txt 执行more命令后，常用的操作向下滚动一屏123z空格键ctrl+f 向上滚动一屏12bctrl+b 输出文件名和当前行的行号1:f 进入vim编辑器1v 退出more模式1q less - 查看文件内容查看文件1less test.txt ps查看进程并通过less分页显示1ps -ef | less 显示当前行数的百分比1less -m test.txt 显示当前行数&#x2F;总行数和百分比1less -M test.txt 显示连续空行为一行1less -s test.txt 进入less模式之后的操作g：移动到第一行 G：移动到最后一行 u：向前移动半屏 d：向后移动半屏 f：向后移动指定行数或一屏 b：向前移动指定行数或一屏 j：向下移动一行 k：向上移动一行 q：结束less模式 nl - 显示行号显示行号，除了空行默认就是这个 12nl test.txtnl -b t test.txt 无论是否为空行，都显示行号1nl -b a test.txt 行号靠最左显示1nl -n ln test.txt 行号靠最右显示1nl -n rn test.txt 行号靠最右显示，不足位数左边补01nl -n rz test.txt find - 查找命令最基础的打印操作1find ~/test 知识点 -print 是默认就有的，不写也可以，而 -print 默认是以 \\n 来分隔找到的文件 如果不想换行打印，可以考虑空格分隔，加上 -print0 即可 1find ~/test -print0 通过文件名搜索 -name：仅可以对文件的file_name匹配 -path：可以对文件的dir_name、file_name匹配 查找的文件名最好使用引号包围，可以配合通配符进行查找 查找~&#x2F;test下的.txt文件1find ~/test -name &quot;*.txt&quot; 在~&#x2F;test下查找cool文件夹下的.txt文件1find ~/test -path &quot;/*cool*/*.txt&quot; 倘若，我们通过-name来执行会是怎么样的呢？是会报错的因为 -name 是不能使用 &#x2F; 的，除非文件名包含了 &#x2F; ， 因为 -name 只能匹配 file_name （即文件名），并不匹配 dir_name （即目录名） 所以想要在指定目录（**~&#x2F;test）下搜索某目录中（&#x2F;cool）的某文件（.txt），应该使用-path而不是-name** 通过文件的类型来搜索在~&#x2F;test目录下查找所有的目录1find ~/test -type d 在~&#x2F;test目录下查找所有的文件1find ~/test -type f 还有其他不常用的文件类型 b：块设备 c：字符设备 p：管道 l：符号链接 通过文件的时间来搜索在~&#x2F;test目录下查找修改时间在5日以内的文件1find ~/test -mtime -5 在~&#x2F;test目录下查找修改时间在3日以前的.txt文件1find ~/test -type f -name &quot;*.txt&quot; -mtime +3 在~&#x2F;test目录下查找更改时间在5分钟以内的.txt文件1find ~/test -type f -name &quot;*.txt&quot; -mmin -5 在~&#x2F;test目录下查找修改时间在10分钟以前的文件1find ~/test -mmin +10 注意点 Linux的文件有三种时间类型，具体可看此文章：https://www.cnblogs.com/poloyy/p/12586677.html 无论是 -mtime +5 还是 -mtime -5 ，第五天内修改过的文件都不会被搜索出来，可看下图 通过文件的大小来搜索语法格式1-size n[cwbkMG] 那么它有什么类型大小单位呢？（官方直接给了答案）b：512字节的块（默认），1b &#x3D; 512c c：bytes，指定字节大小 w：等价于两个bytes，1w&#x3D;2c，一般用户匹配中文 k：平时常说的1kb，1k&#x3D;1024c&#x3D;2b M：1MB，1M&#x3D;1024k&#x3D;2048b G：1GB，1GB&#x3D;1024MB&#x3D;2048*1024b 在~&#x2F;test目录下查找所有size&#x3D;0字节的文件1find ~/test -size 0 在~&#x2F;test目录下查找所有size&lt;100k的文件1find ~/test -size -100k 在~&#x2F;test目录下查找所有size&gt;1MB的文件1find ~/test -size +1M 通过编程中的“与、或、非”来搜索 -a：与，即&amp;&amp;（默认都是与） -o：或：即|| -not：非，即条件结果取反 在~&#x2F;test目录下查找文件大小在1kb和10kb内的所有文件12find ~/test -size +1k -size -10kfind ~/test -size +1k -a -size -10k 在~&#x2F;test目录下查找大于1kb或类型为普通文件的文件1find ~/test -size +1k -o -type f 在~&#x2F;test目录下查找非空文件1find ~/test -not -size 0 在~&#x2F;test目录下查找文件或目录1find ~/test -type f -o -type d 搜索空文件1find ~/test -empty -type f 通过文件所属用户搜索1find ~/test -user root 通过文件所属组group搜索1find ~/test -group root fuser - 断开终端连接命令作用有三种解释 使用文件或 socket 识别进程 显示哪些进程使用命名文件、socket 或文件系统 显示使用指定文件或文件的进程的 pid 系统 总的来说就是文件+进程 语法格式fuser [-fMuvw] [-a|-s] [-4|-6] [-c|-m|-n SPACE] [-k [-i] [-SIGNAL]] NAME… 参数列表 参数 作用 -a,–all 显示未使用的文件 -i,–interactive 杀死前的交互式询问（忽略而不使用-k） -k,–kill 终止访问命名文件的进程 -l,–list 列出可用的信号名称 -m,–mount 显示使用命名文件系统或块设备的所有进程 -M,–ismountpoint 仅当NAME是挂载点时满足请求 -n,–namespace 在此名称空间中搜索命名空间（文件、udp或tcp） -s,–silent 静默操作 -SIGNAL 发送这个信号而不是SIGKILL -u,–user 显示用户ID -v,–verbose 详细输出 -w,–writeonly 杀死具有写访问权限的进程 -V,–version 版本信息 -4,–ipv4 搜索ipv4 socket -6,–ipv6 搜索ipv6 socket - reset 重置 基础用法1fuser /root PID后跟的字符说明了进程以何种方式与该目录&#x2F;文件关联 c 指示进程的工作目录 e 指示该文件为进程的可执行文件(即进程由该文件拉起) f 指示该文件被进程打开，默认情况下f字符不显示 F 指示该文件被进程打开进行写入，默认情况下F字符不显示 r 指示该目录为进程的根目录 m 指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存 . 占位符，默认显示模式中省略 详细输出1fuser -v /root 杀掉进程1fuser -k /dev/pts/0 这是断开本地 ssh 连接阿里云服务器的终端 杀掉进程并询问1fuser -v -i -k /dev/pts/0 last - 查看上次登录用户的列表命令作用 显示上次登录用户的列表 这个是在 Linux 下的 last 命令，跟 Mac 下有点不同 语法格式1last [options] [&lt;username&gt;...] [&lt;tty&gt;...] 参数说明 参数 含义 - 显示多少行 -a, –hostlast last在最后一列中显示主机名 -d, –dns 将IP号转换回主机名 -f, –file &lt;读取特定文件而不是 &#x2F;var&#x2F;log&#x2F;wtmp -F, –fulltimes 打印完整的登录和注销时间和日期 -i, –ip 以数字和点表示法显示ip编号 -n, –limit 限制要显示的行数 -R, –nohostname 不显示hostname字段 -s, –since 显示指定时间以来的行 -t, –until 显示指定时间之前的行 -p, –present 显示在指定时间出现的人员 -w, –fullnames 显示完整的用户名和域名 -x, –system 显示系统关闭条目和运行级别更改 -h, –help 帮助 -V, –version 版本 查看列表说明 第一列：用户名 第二列：终端位置，pts&#x2F;0 (伪终端) 意味着从 SSH 或 telnet 的远程连接的用，.tty (teletypewriter) 意味着直接连接到计算机或者本地连接的用户 第三列：登录的 IP 或终端名，用户通过本地终端连接则显示空，除了重启活动，内核版本会显示在状态中 第四列：登录开始时间 第五列：结束时间 第六列：持续时间，still logged in 表示仍然在线 显示5行，将 host 放在最后一列，打印完整的时间日期，并将 ip 转成主机名1last -5 -a -d -F 不显示 hostname1last -R 显示5行，显示完整的用户名和主机名，并只显示从 2021-06-04 17:33:00 开始到现在的信息1last -5 -w -s 202106041733300 显示5行，并只显示在 2021-06-06 00:00:00 之前的信息1last -5 -t 20210606000000 last 命令的数据源执行 last 命令时，默认读取 &#x2F;var&#x2F;log&#x2F;wtmp 文件 它是一个二进制文件，记录每个用户的登录系统次数和持续时间、注销、系统重启、停机等事件 它是永久记录这些信息的，系统运行时间增加，文件也会越来越大 因为它本身是一个二进制文件，所以无法直接 cat 查看，因此诞生了 last 命令来查看 还有另外一个命令，lastb 它是读取 &#x2F;var&#x2F;log&#x2F;btmp 文件，记录登录系统失败的每个用户 当然，用 last -f 读取这个文件也是一样效果的 &#x2F;var&#x2F;run&#x2F;utmp 它比较重要，记录着当前正在登录系统的每个用户 它的数据结构和 &#x2F;var&#x2F;log&#x2F;wtmp 的数据结构一样 &#x2F;var&#x2F;log&#x2F;lastlog 记录着每个用户最后登录系统的信息 它的数据结构和 &#x2F;var&#x2F;run&#x2F;utmp 、 &#x2F;var&#x2F;log&#x2F;wtmp 不一样 last -f &#x2F;var&#x2F;log&#x2F;wtmp1last -f /var/log/wtmp last -f &#x2F;var&#x2F;log&#x2F;btmp1last -f /var/log/btmp 和 lastb 查出来用户列表信息是一样的 本地用户直接 ssh 登阿里云 因为阿里云没有 polo 这个用户，所以连不上 然后系统就自动记录 polo 用户登录系统失败了 last -f &#x2F;var&#x2F;run&#x2F;utmp1last -f /var/run/utmp 当前就一个 root 用户登录，加上一个系统信息 last -f &#x2F;var&#x2F;log&#x2F;lastlog1last -f /var/log/lastlog 直接用 last -f 好像并不会显示信息，应该是因为读取的文件的数据结构不一致的原因 lastlog1lastlog 后面查了下，可以直接用 lastlog 查看 &#x2F;var&#x2F;log&#x2F;lastlog 实际工作场景：因为某些用户的链接数太多导致无法再连接，此时需要断开用户已存在的终端链接通过 last 找到用户的终端信息，然后用 fuser kill 掉 12lastfuser -k /dev/pts/0 这里就踩了个坑，如果直接敲 pts&#x2F;0 会报错， 因为路径不对，需要加上根路径 &#x2F;dev&#x2F;pts&#x2F;0 杀掉当前终端链接文件后，我的 ssh 连接就自动退掉了 重新 ssh 连接服务器，查看之前的登录信息 通过 fuser 批量杀掉同一个用户的终端链接1fuser -k $(last -w | grep name | awk &#x27;&#123;print &quot;/dev/&quot;$2&#125;&#x27;) 自己换掉 name 直接 ps -ef 去删掉1ps -ef|grep name | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9 curl - 调试接口命令 curl 是常用的命令行工具，用来请求 Web 服务器 它的名字就是客户端（client）的 URL 工具的意思 它的功能非常强大，命令行参数多达几十种 如果熟练的话，完全可以取代 Postman 接口测试工具 官方文档https://curl.se/docs/manpage.html 支持的协议 DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS IMAP、IMAPS、LDAP、LDAP、POP3、POP3、RTMP、RTSP、SCP、SFTP、SMB SMBS、SMTP、SMTPS、TELNET、TFTP 提供强大的功能 代理支持 用户身份验证 FTP上传 httppost SSL连接 cookies 文件传输恢复 Metalink 等等 语法格式1curl [options / URLs] 内容较多请查看这篇文章:https://www.cnblogs.com/poloyy/p/14854183.html 其他指令下载或者上传需要软件安装包下载:1yum 上传:12scpsz 修改文件内容:1vi 修改权限:1chmod 应用配置:1source 配置文件名 安装项目, 运行并测试访问(1)初始化数据库接口及基本数据1.由开发提供数据库初始化脚本(一般以 xxx.sql 结尾) 2.命令行连接到数据库命令格式 1mysql -u用户名 -p密码 3.初始化数据库结构与基本数据命令格式 1source xxx.sql (2)启动项目以 Java 程序为例命令格式 1java -jar 程序名.jar grep - 查找关键字grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 **-**，则 grep 指令会从标准输入设备读取数据。 语法123grep [options] pattern [files]或grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...] pattern - 表示要查找的字符串或正则表达式。 files - 表示要查找的文件名，可以同时查找多个文件，如果省略 files 参数，则默认从标准输入中读取数据。 常用选项：： -i：忽略大小写进行匹配。 -v：反向查找，只打印不匹配的行。 -n：显示匹配行的行号。 -r：递归查找子目录中的文件。 -l：只打印匹配的文件名。 -c：只打印匹配的行数。 更多参数说明： -a 或 –text : 不要忽略二进制的数据。 -A&lt;显示行数&gt; 或 –after-context&#x3D;&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; 或 –before-context&#x3D;&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c 或 –count : 计算符合样式的列数。 -C&lt;显示行数&gt; 或 –context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; 或 –directories&#x3D;&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; 或 –regexp&#x3D;&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。 -E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。 -f&lt;规则文件&gt; 或 –file&#x3D;&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 –fixed-regexp : 将样式视为固定字符串的列表。 -G 或 –basic-regexp : 将样式视为普通的表示法来使用。 -h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 –ignore-case : 忽略字符大小写的差别。 -l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。 -L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。 -n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 –only-matching : 只显示匹配PATTERN 部分。 -q 或 –quiet或–silent : 不显示任何信息。 -r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。 -s 或 –no-messages : 不显示错误信息。 -v 或 –invert-match : 显示不包含匹配文本的所有行。 -V 或 –version : 显示版本信息。 -w 或 –word-regexp : 只显示全字符合的列。 -x –line-regexp : 只显示全列符合的列。 -y : 此参数的效果和指定”-i”参数相同。 实例1、在文件 file.txt 中查找字符串 “hello”，并打印匹配的行： 1grep hello file.txt 2、在文件夹 dir 中递归查找所有文件中匹配正则表达式 “pattern” 的行，并打印匹配行所在的文件名和行号： 1grep -r -n pattern dir/ 3、在标准输入中查找字符串 “world”，并只打印匹配的行数： 1echo &quot;hello world&quot; | grep -c world 4、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： 1grep test *file 结果如下所示： 1234$ grep test test* #查找前缀有“test”的文件包含“test”字符串的文件 testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行 testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行 testfile_2:Linux test #列出testfile_2 文件中包含test字符的行 5、以递归的方式查找符合条件的文件。例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为： 1grep -r update /etc/acpi 输出结果如下： 1234567$ grep -r update /etc/acpi #以递归的方式查找“etc/acpi” #下包含“update”的文件 /etc/acpi/ac.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than /etc/acpi/resume.d/85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than /etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update 6、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。 查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为： 1grep -v test *test* 结果如下所示： 123456789$ grep-v test* #查找文件名中包含test 的文件中不包含test 的行 testfile1:helLinux! testfile1:Linis a free Unix-type operating system. testfile1:Lin testfile_1:HELLO LINUX! testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM. testfile_1:THIS IS A LINUX TESTFILE! testfile_2:HELLO LINUX! testfile_2:Linux is a free unix-type opterating system. Linux 命令大全","categories":[{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/categories/Liunx/"}],"tags":[{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/tags/Liunx/"}],"author":"Noir"},{"title":"appium常见用法","slug":"appium常见用法","date":"2023-06-17T18:24:53.101Z","updated":"2023-06-19T11:21:31.561Z","comments":true,"path":"2023/06/18/appium常见用法/","link":"","permalink":"http://example.com/2023/06/18/appium%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/","excerpt":"","text":"基本代码(启动代码) 准备工作 123456781. 打开模拟器或者连接真机2. 打开 appium 并启动服务器3. 获取被测 app 的包名和界面名Windows:adb shell dumpsys window windows | findstr mFocusedAppadb shell dumpsys window | findstr mCurrentFocus com.android.settings/.Settings 代码 12345678910111213141516171819import timefrom appium import webdriverdesired_capabilities = &#123; &quot;platformName&quot;: &quot;Android&quot;, # 手机的平台 不区分大小写 &quot;platformVersion&quot;: &quot;7&quot;, # 版本, 写大版本即可,比如 6.2.1 可以写在 6.2 6 &quot;deviceName&quot;: &quot;emulator-5554&quot;, # 手机的名字,随便写一个字符串,不能不写 &quot;appPackage&quot;: &quot;com.android.settings&quot;, # 打开应用的包名 &quot;appActivity&quot;: &quot;.Settings&quot; # 界面名（也叫启动名）&#125;# 获取驱动 http://127.0.0.1:4723/wd/hub 连接appium服务，# python和appium通信使用http协议driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_capabilities)time.sleep(5)# 退出驱动driver.quit()# 注意：如果版本号写错，会有提示版本 noReset参数12345678910111213打开app，如果重置了，下次再次打开此app，会和新安装的app一样（没有缓存，重新输入密码，提示获取权限，引导页）desired_capabilities = &#123; &quot;platformName&quot;: &quot;Android&quot;, # 平台 不区分大小写 &quot;platformVersion&quot;: &quot;7&quot;, # 版本, 写大版本即可,比如 6.0 可以写在 6 &quot;deviceName&quot;: &quot;emulator-5554&quot;, # 手机的名字,随便写一个字符串,不能不写 &quot;appPackage&quot;: &quot;com.tpshop.malls&quot;, # 打开应用的包名 &quot;appActivity&quot;: &quot;.SPMainActivity&quot;, # 界面名 &quot;noReset&quot;: True&#125;&quot;noReset&quot;: True打开app，不重置；如果不传递此参数，打开app默认会重置应用。 app 的基本操作应用跳转123456# appium是支持跨应用的，同一个session可以打开多个 app# 使用场景：当需要打开其它app时，可以使用此方法driver.start_activity(appPackage, appActivity)- appPackage 包名- appActivity 界面名 获取包名和界面名12# 获取包名 driver.current_package# 获取界面名 driver.current_activity 使用场景：获取界面名，用于断言 关闭驱动和app12# driver.close_app()，关闭的是desired_capabilities中的app# 关闭驱动 driver.quit() 关闭了session会话 扩展：关闭指定app 1234扩展：# 指定app关闭，使用 driver.terminate_app(app的id)# app的id 就是 包名# close_app() 只能关闭desired_capabilities指定的app， 在将来会被舍弃 安装卸载判断是否安装12345678# 安装app，app_path 为安装文件完整路径名(写绝对路径) driver.install_app(app_path)# 卸载app，app_id为app包名 driver.remove_app(app_id)# 判断app是否安装，app_id为app包名 driver.is_app_installed(app_id) 路径解决办法 12345windows 的路径问题解决：1. 在路径前边的字符串前加上 r&quot;&quot; , 不会进行转义 r&quot;D:\\apks\\TPShop.apk&quot;2. 将 Windows 路径为： \\ 改为 linux路径： / &quot;D:/apks/TPShop.apk&quot;3. 将 \\ 改为 \\\\ &quot;D:\\\\apks\\\\TPShop.apk&quot; 将应用 置于后台12345# 将当前应用置于后台多少秒, 时间到了之后,会自动切换到前台# 使用场景：手机银行类app，应用置于后台一段时间，再切换到前台，需要重新进行身份认证# 语法：driver.background_app(seconds) &#x3D;&#x3D;2.2元素定位&#x3D;&#x3D;定位单个元素12345元素定位工具: 使用 SDK 中的 ui 工具# xpath语法回顾//*[@属性名=&#x27;属性值&#x27;]//*[contains(@属性名, &#x27;属性值&#x27;)] 定位单个元素12345元素定位工具: 使用 SDK 中的 ui 工具# xpath语法回顾//*[@属性名=&#x27;属性值&#x27;]//*[contains(@属性名, &#x27;属性值&#x27;)] 元素定位-定位一组元素1234# 通过另外一种写法来定位driver.find_elements() # 得到的是 列表, 如果没有找到,返回的也是空列表#注意： appium 只能定位到页面展示的元素 &#x3D;&#x3D;元素操作&#x3D;&#x3D;2.3.1点击&#x2F;输入&#x2F;清空1234567891011121314151617点击、el.click()输入、el.send_keys(内容)清空el.clear()补充：1.默认不能输入中文(Windows),想要输入中文, 需要在启动参数中添加如下内容 unicodeKeyboard 和 resetKeyboard 两个键值对, 值都是 Truedesired_capabilities&#123; &quot;unicodeKeyboard&quot;: True, &quot;resetKeyboard&quot;: True&#125;2. appium-python-client send_keys() 会将输入框中的内容进行清空后，再输入 获取元素文本、位置、大小**1234561. 获取文本el.text 2. 位置el.location3. 大小el.size 获取元素属性123456789101112134. 属性el.get_attribute(属性名 )- ID: resourceId- content-desc: content-desc- 获取 class: className- 获取 text ： text/name注意： 老版本appium 获取name属性，当content-desc为空时，获取的是text属性，当content-desc不为空时，返回是 content-desc 当前版本1.20 如何想获取content-desc直接传入 content-desc 滑动和拖拽&#x3D;&#x3D;swipe滑动&#x3D;&#x3D;123456789driver.swipe(start_x, start_y, end_x, end_y, duration=0)start_x: 起点X轴坐标 start_y: 起点Y轴坐标 end_x: 终点X轴坐标 end_y: 终点Y轴坐标duration: 滑动这个操作一共持续的时间长度，单位:ms, 时间越短，惯性越大，如果不需要惯性，设置5000左右。如果需要惯性-设置200ms练习：打开手机《设置》应用，完成下面的步骤:①.模拟手指从（500, 1600），滑动到（500, 500）的位置。 scroll 滑动1234567891011从一个元素滑动到另一个元素，直到页面自动停止driver.scroll(origin_el, destination_el, duration) origin_el: 开始元素destination_el: 结束元素duration: 滑动时间滑动时间：时间越短，惯性越大案例：从 显示 滑动到 WLAN drag_and_drop123456从一个元素拖拽到另一个元素, 无惯性(精确滑动)driver.drag_and_drop(开始元素, 结束元素)注意：没有惯性，精准的滑动案例：从 显示 滑动到 WLAN 滑动方式选择12* 是通过坐标滑动还是通过元素滑动* 是否需要惯性 通过坐标滑动 不需要惯性 swipe，持续时间duration设置的长一些（4000-5000ms） 需要惯性 swipe，持续时间duration设置短一些(100-200ms) 通过元素滑动 不需要惯性 scroll + duration设置长一些（4000-5000ms） drag_and_drop 需要惯性 scroll+duration设置的短一些(100-200ms) web-editor 有一些面试会提到，市面上有些人会使用这个工具 1234# 安装pip install weditor==0.6.3# 启动weditor 注意：运行代码前，需要关闭weditor 如果未手动停止，则报如下错误 appium自带查询元素信息1.启动appium服务器 2.创建New Session Window 5.真机调试华为 安装手机助手 手机连入计算机，会提示安装 使用360软件-搜索手机助手 根据手机助手进行连接 开启开发者模式 开启adb 和 usb调试模式 安装手机助手进行调试(和手机品牌有关) 查看是否连接成功 &#x3D;&#x3D;手势操作&#x3D;&#x3D;基本语法1234567891011移动端的手势操作 类似 web 端的鼠标操作1. 创建TouchAction对象 touch_action = TouchAction(driver)2. 调用高级手势对象提供所想执行的手势方法 touch_action.手势方法3. 执行手势 touch_action.perform()-----另外一种写法TouchAction(driver).手势方法.perform() 轻敲 tap123456789轻敲的结果类似 点击tap(el, x, y)- el: 元素对象- x: 点击 x 坐标- y: 点击 y 坐标注意：1.元素对象 和 坐标 任选其一,不用两个都选2.如果通过 坐标进行点击，页面打开需要时间，带点击前需要手动等待 time.sleep() 按下 和 抬起123456789101. 按下press(el=None,x=None,y=None)2. 抬起release()模拟 轻敲 (按下马上抬起)press(el=None,x=None,y=None).release()模拟 长按(按下不抬起)press(el=None,x=None,y=None) 长按1234long_press(el, x, y, duration=1000)- el: 元素对象- x, y: 坐标- duration: 长按的时间,单位时间是毫秒 思考时间12wait(ms) # ms 毫秒, 暂停多长时间使用按下和抬起 组合思考时间，实现长按 1234# 通过 press release wait 模拟长按3秒driver.find_element_by_xpath(&quot;//*[@text=&#x27;WLAN&#x27;]&quot;).click()time.sleep(2)TouchAction(driver).press(x=280, y=490).wait(3000).release().perform() 移动 move_to12345ove_to(el, x, y)# 实际场景1. 想移动,需要先按下2. 移动完成后, 需要抬起 一个app 一般 只有一个启动页，一般是首页 滑动操作实际是使用了手势操作-TouchAction 123456# swipe 代码def swipe(self: T, start_x: int, start_y: int, end_x: int, end_y: int, duration: int = 0) -&gt; T: action = TouchAction(self) action.press(x=start_x, y=start_y).wait(ms=duration).move_to(x=end_x, y=end_y).release() action.perform() return self &#x3D;&#x3D;手机操作&#x3D;&#x3D;获取屏幕分辨率和截图12345语法：获取手机分辨率: driver.get_window_size() ---&gt; 字典 &#123;&#x27;width&#x27;: 1440, &#x27;height&#x27;: 2392&#125;截图: get_screenshot_as_file(filename) time.strftime(&#x27;%Y%m%d-%H%M%S&#x27;) 给文件名添加后缀 获取和设置网络状态123456781. 获取网络状态driver.network_connection 2. 设置网络状态driver.set_network_connection(connection_type)- connection_type: 网络类型(0, 1, 2, 4, 6)@property 装饰器，可以将 实例方法作为属性来使用 获取和设置网络状态123456781. 获取网络状态driver.network_connection 2. 设置网络状态driver.set_network_connection(connection_type)- connection_type: 网络类型(0, 1, 2, 4, 6)@property 装饰器，可以将 实例方法作为属性来使用 发送键到设备(按键操作)1234567891011121314151617语法：driver.press_keycode(keycode)常用：Home 键(返回主页) 3返回键 4音量增加键 24音量减少键 25回车键 66注意：# 1.音量大小未显示时，按 音量加和音量减 只会唤醒 音量大小调整界面# 2.按键过快，会产生无效按键操作keycode查询https://blog.csdn.net/feizhixuan46789/article/details/16801429 &#x3D;&#x3D;通知栏的操作&#x3D;&#x3D;123456语法：打开通知栏: driver.open_notifications()appium官方并没有为我们提供关闭通知的api，那么 现实生活中怎么关闭，就怎样操作就行，比如，1.手指从下往 上滑动2.按返回键 &#x3D;&#x3D;获取 toast 信息&#x3D;&#x3D;toast操作 介绍： 操作过程中弹出的立即消失的弹出框， 本质上它也是页面的一个元素。 如何获取toast：建议使用xpath查询，因为使用工具很难定位到元素。 1driver.find_element(By.XPATH, &quot;//*[contains(@text, &#x27;toast中的部分文本内容&#x27;)]&quot;) 使用显示等待查找元素： 隐式等待的下一次找元素的频率，不适合这种一闪而过的toast 1element = WebDriverWait(driver, 30, 0.1).until(lambda x: x.find_element(By.XPATH, &quot;//*[contains(@text,&#x27;再次点击&#x27;)]&quot;)) 补充说明 新版本的appium软件，支持Uiautomator2 因此不需要安装特殊环境 123低版本的 appium(&lt;=1.13) 需要在启动参数中添加如下内容:desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27;高版本默认使用的就是 封装方法-获取toast 获取toast封装获取toast文本内容 1234567891011121314# 提供要获取toast部分文本，判断toast是否存在，如果存在，则返回文本内容，如果没有找到，则抛出异常文本未找到from selenium.webdriver.common.by import Byfrom selenium.webdriver.support.wait import WebDriverWaitdef get_toast(driver, content): &quot;&quot;&quot;根据部分toast，获取完整toast信息&quot;&quot;&quot; el_xpath = f&quot;//*[contains(@text, &#x27;&#123;content&#125;&#x27;)]&quot; el = WebDriverWait(driver, 10, 0.5).\\ until(lambda x: x.find_element(By.XPATH, el_xpath)) return el.text webviewApp分类123Native App 原生app, Web App 使用浏览器打开的应用，页面是用HTML实现的Hybrid App 混合应用, 在原生 app 中嵌套了 HTML 网页 手机中HTML页面如何操作 12webview 的作用是嵌套 HTML 页面.嵌套的 HTML 页面,不能直接使用移动端的元素定位,要使用 web 端的元素定位,就需要 web 端的 driver(Chrome) &#x3D;&#x3D;环境准备&#x3D;&#x3D;1.查看应用浏览器的版本。 方式一：在应用-&gt;显示系统进程-&gt;找到Android system webview版本。 不同手机模拟器和真机略有不同，推荐方式二 方式二：使用命令，在dos命令行中输入命令，在手机中查看 1adb shell am start -a android.intent.action.VIEW -d https://liulanmi.com/labs/core.html 2.下载对应的版本的浏览器内核 下载地址： http://npm.taobao.org/mirrors/chromedriver/ 3.根据手机浏览器版本在上面页面中找到对应的版本 https://cdn.npmmirror.com/binaries/chromedriver/2.42/notes.txt 4.解压放到固定目录。12# 将下载好的手机浏览器版本对应的驱动 chromedriver放置到没有中文的目录，建议不要放在path中D:\\tools\\app_tools\\chrome\\chromedriver.exe 5.程序配置”Chromdriver Binary Path”目录 打开 Appium-Server Desktop 程序配置”Chromdriver Binary Path”目录为第三部中的全路径。 点击 “Start Server”开启Appium Server Desktop &#x3D;&#x3D;webview 元素定位&#x3D;&#x3D;思路 浏览器本身是native的应用。 使用之前的native元素定位、交互即可 网页部分的内容是HTML页面， 和native部分使用了不同的上下文。 做完native部分的交互(地址输入、回车访问)之后。 需要切换到HTML页面。代码如下： 12# 在 原生应用和 webview 之间进行切换driver.switch_to.context(&quot;&quot;) 切换完成后使用web页面自动化的方式定位元素、进行操作即可。 注意：如果模拟器上的浏览器为chrome， web页面的定位只能使用CSS、XPATH定位， 其他不支持。 &#x3D;&#x3D;方法API&#x3D;&#x3D;123456789101112131415161718192021# 语法:获取所有的上下文,得到是列表driver.contexts [&#x27;NATIVE_APP&#x27;, &#x27;WEBVIEW_com.android.browser&#x27;]# 获取当前的上下文对象driver.context # 切换到指定的上下文对象driver.switch_to.context(上下文对象) # 备注：操作原生页面，需要切换到原生上下文，如果操作webview 需要切换到webview的上下文# 注意：# 部分版本的浏览器驱动存在问题原因会导致如下报错selenium.common.exceptions.InvalidArgumentException: Message: invalid argument: invalid locator (Session info: chrome=86.0.4240.198)请在 desired_capabilities添加如下两个参数&quot;chromeOptions&quot;: &#123;&#x27;w3c&#x27;: False&#125;Chrome和ChromeDriver组合默认在w3c模式下运行,只有手动指定 ChromeDriver运行模式为非w3c模式，才能规避这个bug","categories":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://example.com/tags/appium/"}],"author":"Noir"},{"title":"selenium常见用法","slug":"selenium常见交互","date":"2023-06-17T09:47:43.314Z","updated":"2023-06-19T11:21:26.518Z","comments":true,"path":"2023/06/17/selenium常见交互/","link":"","permalink":"http://example.com/2023/06/17/selenium%E5%B8%B8%E8%A7%81%E4%BA%A4%E4%BA%92/","excerpt":"","text":"selenium常见用法点击+输入+清空1234561. 元素点击element.click()2. 输入element.send_keys(内容)3. 清除element.clear() 大小&#x2F;文本&#x2F;属性1234561. 大小element.size2. 文本element.text3. 属性element.get_attribute(&#x27;属性名&#x27;) 判断元素是否可见123element.is_displayed()可见 : True不可见: False 判断元素是否可用12345简单的理解,可以认为是是否可以点击element.is_enabled()可用: True不可用: False 判断元素是否被选中123element.is_selected()选中: True未选中: False 浏览器常见的操作设置浏览器显示范围1234561. 窗口最大化 -- 重点driver.maximize_window() 2. 设置窗口大小dirver.set_window_size(width, height)3. 设置窗口位置dirver.set_window_position(x, y) 浏览器显示页面操作1234561. 页面后退操作driver.back()2. 页面前置操作driver.forword()3. 刷新driver.refresh() -- 重点 关闭窗口&#x2F;关闭浏览器12341. 关闭当前窗口driver.close() 关闭当前窗口2. 关闭浏览器driver.quit() 不管有多少个打开的窗口,都会直接关闭退出 获取标题&#x2F;URL123456作为页面断言的内容使用1. 标题driver.title2. URLdriver.current_url 下拉框 12345678910111. 在 HTML 页面中, 可以下拉选择内容的的称为是下拉框2. 下拉框的标准实现是 select 标签和 option 结合3. 下拉框中的内容是可以直接使用 元素定位的4. 如果,下拉框是 select 实现的, 推荐使用 selenium 中提供的方法去操作- 1. 创建Select 类(selenium 提供的)的对象- 对象 = Select(元素对象)- 2. 通过对象选择下拉框中的内容即可- - 对象.select_by_index(index) 根据索引选择, 从 0 开始- - 对象.select_by_value(value) 根据 value 属性值选择- - 对象.select_by_visible_text(text) # 根据文本内容选择 弹出框 12345678910111213141, 弹出框分为自定义弹出框 和 JS 弹出框2, 区分方式: 根据是否可以右键检查元素来区分, 如果可以检查元素, 就是自定义弹出框, 如果不能检查元素,就是 JS 弹出框3. 自定义弹出框的处理方式: 直接元素定位解决4. JS 弹出框的处理(alert(警告框)、confirm(确认框)、 prompt(提示框)), 这三种 JS 弹出框的处理方案是一样的.- 1. 获取弹出框对象: 对象 = driver.switch_to.alert- 2. 对弹出框进行处理:- - 确认: 对象.accept()- - 取消: 对象.dismiss()- 其他操作: 获取弹出框的内容 对象.text- prompt 提示框,输入内容,使用的也是 对象.send_keys()注意：在处理弹出框或者具有动画效果的页面，先等待页面加载完成后，再进行操作先等待几秒，在进行页面操作 滚动条123451, selenium 没有提供 直接操作滚动条的方法2, JS(javascript) 是可以 操作滚动条 js = &quot;window.scrollTo(x,y)&quot;3, selenium 提供的操作 JS 代码的方法 driver.execute_script(js) 鼠标操作1234567891011120. # 导包from selenium.webdriver import ActionChains1. 实例化鼠标对象mouse = ActionChains(driver)2. 书写要进行的鼠标操作mouse.操作()- move_to_element(元素对象) 鼠标悬停- context_click(元素对象) 鼠标右击- double_click(元素对象) 鼠标双击(选中)- drag_and_drop(开始元素对象, 结束元素对象) 拖拽3. 执行鼠标动作(必须有执行)mouse.perform() 鼠标悬停、鼠标右键、鼠标双击123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 1) 将鼠标悬停在 注册按钮上# 1, 实例化对象# action = ActionChains(driver)## # 2, 书写鼠标操作# action.move_to_element(driver.find_element(By.TAG_NAME, &#x27;button&#x27;))# # # 3, 执行鼠标操作# action.perform()# 导包import timefrom selenium import webdriver# 获取浏览器驱动对象from selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()# 打开注册A页面driver.get(&quot;http://121.43.169.97:8848/pageA.html&quot;)# 设置浏览器最大化driver.maximize_window()# 定位用户名输入框userA = driver.find_element(By.ID, &quot;userA&quot;)# 创建ActionChains 对象 actionaction = ActionChains(driver)# action调用鼠标右键的方法userA.send_keys(&quot;haha&quot;)action.context_click(userA).pause(2).double_click()# 调用perform方法time.sleep(2)action.perform()# 用户名输入 admintime.sleep(2)userA.send_keys(&quot;admin&quot;)# action调用鼠标双击方法action.double_click(userA)# 调用performtime.sleep(2)action.perform()# 3秒后关闭浏览器窗口time.sleep(5)driver.quit() 鼠标拖拽12345678910# 定位元素 div1 div2 用户拖拽div1 = driver.find_element(By.ID, &quot;div1&quot;)div2 = driver.find_element(By.ID, &quot;div2&quot;)# 创建 ActionChains对象action = ActionChains(driver)# action 调用 拖拽方法action.drag_and_drop(div1, div2)# action 调用 perform函数action.perform()","categories":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"selenium","slug":"selenium","permalink":"http://example.com/tags/selenium/"}],"author":"Noir"}],"categories":[{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/categories/Liunx/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Liunx","slug":"Liunx","permalink":"http://example.com/tags/Liunx/"},{"name":"自动化","slug":"自动化","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"appium","slug":"appium","permalink":"http://example.com/tags/appium/"},{"name":"selenium","slug":"selenium","permalink":"http://example.com/tags/selenium/"}]}